
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.1.2, mkdocs-material-6.2.5">
    
    
      
        <title>Intel® Security Libraries - Datacenter SGX Attestation Infrastructure and Secure Key Caching - Intel® SecL-DC</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.15aa0b43.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.75751829.min.css">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto",-apple-system,BlinkMacSystemFont,Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono",SFMono-Regular,Consolas,Menlo,monospace}</style>
      
    
    
    
    
      
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="none" data-md-color-accent="none">
      
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#intel-security-libraries-datacenter-sgx-attestation-infrastructure-and-secure-key-caching" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid" aria-label="Header">
    <a href="../.." title="Intel® SecL-DC" class="md-header-nav__button md-logo" aria-label="Intel® SecL-DC">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header-nav__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header-nav__title" data-md-component="header-title">
      <div class="md-header-nav__ellipsis">
        <div class="md-header-nav__topic">
          <span class="md-ellipsis">
            Intel® SecL-DC
          </span>
        </div>
        <div class="md-header-nav__topic">
          <span class="md-ellipsis">
            
              Intel® Security Libraries - Datacenter SGX Attestation Infrastructure and Secure Key Caching
            
          </span>
        </div>
      </div>
    </div>
    
      <label class="md-header-nav__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" data-md-component="search-reset" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header-nav__source">
        
<a href="https://raghav19.github.io/docs" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    intel-secl/intel-secl
  </div>
</a>
      </div>
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    




<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="Intel® SecL-DC" class="md-nav__button md-logo" aria-label="Intel® SecL-DC">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 003-3 3 3 0 00-3-3 3 3 0 00-3 3 3 3 0 003 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    Intel® SecL-DC
  </label>
  
    <div class="md-nav__source">
      
<a href="https://raghav19.github.io/docs" title="Go to repository" class="md-source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M439.55 236.05L244 40.45a28.87 28.87 0 00-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 01-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 000 40.81l195.61 195.6a28.86 28.86 0 0040.8 0l194.69-194.69a28.86 28.86 0 000-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    intel-secl/intel-secl
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        Welcome to Intel® SecL-DC
      </a>
    </li>
  

    
      
      
      


  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2" >
      
      <label class="md-nav__link" for="nav-2">
        Quick Start Guide
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="Quick Start Guide" data-md-level="1">
        <label class="md-nav__title" for="nav-2">
          <span class="md-nav__icon md-icon"></span>
          Quick Start Guide
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-2-1" type="checkbox" id="nav-2-1" >
      
      <label class="md-nav__link" for="nav-2-1">
        Foundational & Workload
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="Foundational & Workload" data-md-level="2">
        <label class="md-nav__title" for="nav-2-1">
          <span class="md-nav__icon md-icon"></span>
          Foundational & Workload
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../quick-start-guide/foundational_workload/pre-reqs/" class="md-nav__link">
        Pre-requisites
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../quick-start-guide/foundational_workload/build/" class="md-nav__link">
        Build
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../quick-start-guide/foundational_workload/deploy/" class="md-nav__link">
        Deploy
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../quick-start-guide/foundational_workload/workflows/" class="md-nav__link">
        Workflows
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../quick-start-guide/foundational_workload/appendix/" class="md-nav__link">
        Appendix
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

          
            
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-2-2" type="checkbox" id="nav-2-2" >
      
      <label class="md-nav__link" for="nav-2-2">
        Secure Key Caching
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="Secure Key Caching" data-md-level="2">
        <label class="md-nav__title" for="nav-2-2">
          <span class="md-nav__icon md-icon"></span>
          Secure Key Caching
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../quick-start-guide/secure_key_caching/pre-reqs/" class="md-nav__link">
        Pre-requisites
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../quick-start-guide/secure_key_caching/build/" class="md-nav__link">
        Build
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../quick-start-guide/secure_key_caching/deploy/" class="md-nav__link">
        Deploy
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../quick-start-guide/secure_key_caching/workflows/" class="md-nav__link">
        Workflows
      </a>
    </li>
  

          
            
  
  
  
    <li class="md-nav__item">
      <a href="../../quick-start-guide/secure_key_caching/appendix/" class="md-nav__link">
        Appendix
      </a>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
      
      
      


  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3" checked>
      
      <label class="md-nav__link" for="nav-3">
        Product Guide
        <span class="md-nav__icon md-icon"></span>
      </label>
      <nav class="md-nav" aria-label="Product Guide" data-md-level="1">
        <label class="md-nav__title" for="nav-3">
          <span class="md-nav__icon md-icon"></span>
          Product Guide
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
          
            
  
  
  
    <li class="md-nav__item">
      <a href="../Product%20Guide%20-%20Intel%C2%AE%20Security%20Libraries%20-%20Datacenter%20Foundational%20Security/" class="md-nav__link">
        Intel® Security Libraries - Datacenter Foundational Security
      </a>
    </li>
  

          
            
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Intel® Security Libraries - Datacenter SGX Attestation Infrastructure and Secure Key Caching
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Intel® Security Libraries - Datacenter SGX Attestation Infrastructure and Secure Key Caching
      </a>
      
        
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#product-guide" class="md-nav__link">
    Product Guide
  </a>
  
    <nav class="md-nav" aria-label="Product Guide">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#january-2020" class="md-nav__link">
    January 2020
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#revision-331" class="md-nav__link">
    Revision 3.3.1
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#product-guide" class="md-nav__link">
    Product Guide
  </a>
  
    <nav class="md-nav" aria-label="Product Guide">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#january-2020" class="md-nav__link">
    January 2020
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#revision-331" class="md-nav__link">
    Revision 3.3.1
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="intel-security-libraries-datacenter-sgx-attestation-infrastructure-and-secure-key-caching">Intel® Security Libraries - Datacenter SGX Attestation Infrastructure and Secure Key Caching</h1>
<h2 id="product-guide">Product Guide</h2>
<h3 id="january-2020">January 2020</h3>
<h3 id="revision-331">Revision 3.3.1</h3>
<p>Notice: This document contains information on products in the design phase of development. The information here is subject to change without notice. Do not finalize a design with this information.</p>
<p>Intel technologies’ features and benefits depend on system configuration and may require enabled hardware, software, or service activation. Learn more at intel.com, or from the OEM or retailer.</p>
<p>No computer system can be absolutely secure. Intel does not assume any liability for lost or stolen data or systems or any damages resulting from such losses.</p>
<p>You may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products described herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject matter disclosed herein.</p>
<p>No license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document.</p>
<p>The products described may contain design defects or errors known as errata which may cause the product to deviate from published
specifications. Current characterized errata are available on request.</p>
<p>This document contains information on products, services and/or processes in development. All information provided here is subject to
change without notice. Contact your Intel representative to obtain the latest Intel product specifications and roadmaps.</p>
<p>Intel disclaims all express and implied warranties, including without limitation, the implied warranties of merchantability, fitness for a particular purpose, and non-infringement, as well as any warranty arising from course of performance, course of dealing, or usage in trade.</p>
<p>Warning: Altering PC clock or memory frequency and/or voltage may (i) reduce system stability and use life of the system, memory and
processor; (ii) cause the processor and other system components to fail; (iii) cause reductions in system performance; (iv) cause additional heat or other damage; and (v) affect system data integrity. Intel assumes no responsibility that the memory, included if used with altered clock frequencies and/or voltages, will be fit for any particular purpose.
Check with memory manufacturer for warranty and additional details.</p>
<p>Tests document performance of components on a particular test, in specific systems. Differences in hardware, software, or configuration
will affect actual performance. Consult other sources of information to evaluate performance as you consider your purchase. For more complete information about performance and benchmark results, visit <a href="http://www.intel.com/performance">http://www.intel.com/performance</a>.</p>
<p>Cost reduction scenarios described are intended as examples of how a given Intel- based product, in the specified circumstances and
configurations, may affect future costs and provide cost savings. Circumstances will vary. Intel does not guarantee any costs or cost
reduction.</p>
<p>Results have been estimated or simulated using internal Intel analysis or architecture simulation or modeling, and provided to you for
informational purposes. Any differences in your system hardware, software or configuration may affect your actual performance.</p>
<p>Intel does not control or audit third-party benchmark data or the web sites referenced in this document. You should visit the referenced web site and confirm whether referenced data are accurate.</p>
<p>Intel is a sponsor and member of the Benchmark XPRT Development Community, and was the major developer of the XPRT family of benchmarks. Principled Technologies is the publisher of the XPRT family of benchmarks. You should consult other information and performance tests to assist you in fully evaluating your contemplated purchases.</p>
<p>Copies of documents which have an order number and are referenced in this document may be obtained by calling 1-800-548-4725 or by visiting w<a href="http://www.intel.com/design/literature.htm">ww.intel.com/design/literature.htm.</a></p>
<p>Intel, the Intel logo, Intel TXT, and Xeon are trademarks of Intel Corporation in the U.S. and/or other countries.</p>
<p>*Other names and brands may be claimed as the property of others.</p>
<p>Copyright © 2020, Intel Corporation. All Rights Reserved.</p>
<p>Revision History</p>
<p>[[<em>TOC</em>]]</p>
<h1 id="1-introduction">1 Introduction</h1>
<h2 id="11-overview">1.1 Overview</h2>
<p>The SGX Attestation infrastructure and Secure Key Caching (SKC) are part of the Intel Security Libraries for datacenter (ISecL-DC). Intel Security Libraries for Datacenter is a collection of software applications and development libraries intended to help turn Intel platform security features into real-world security use cases.</p>
<p>The SGX Attestation infrastructure provides an end to end support for registering SGX hosts and provisioning them with SGX material (PCK certificates) and SGX collateral (security patches information - TCB Information - and Certificate Revocation Lists - CRLs).</p>
<p>The SGX Attestation infrastructure also provides support for generating SGX quotes for SGX enclaves hosted by workloads and verifying them by a remote attesting application. The remote attesting application can also use the SGX Attestation infrastructure to enforce enclave policies (like requiring a specific enclave signer). Optionally, the SGX Attestation Infrastructure allows to integrate with Cloud Orchestrators like Openstack and Kubernetes.</p>
<p>SKC leverages the SGX Attestation Infrastructure to support the Secure Key Caching (SKC) use case.SKC provides the key protection at rest and in-use use case using the Intel Software Guard Extensions technology (SGX). SGX implements the Trusted Execution Environment (TEE) paradigm.</p>
<p>Using the SKC Client -- a set of libraries -- applications can retrieve keys from the ISecL-DC Key Broker Service (KBS) and load them to an SGX-protected memory (called SGX enclave) in the application memory space. KBS performs the SGX enclave attestation to ensure that the application will store the keys in a genuine SGX enclave. Application keys are wrapped with an enclave public key by KBS prior to transferring to the application enclave. Consequently, application keys are protected from infrastructure admins, malicious applications and compromised HW/BIOS/OS/VMM. SKC does not require the refactoring of the application because it supports a standard PKCS#11 interface.</p>
<h2 id="trusted-execution-environment">Trusted Execution Environment</h2>
<p>A Trusted Execution Environment (TEE) provides a computer secure area where code and data can be loaded with the assurance that their confidentiality and integrity are protected. TEEs have various applications in areas where the confidentiality of the data and the integrity of the code are of the highest importance. One examples of a TEE usage is the protection of sensitive secrets like cryptographic keys and authentication strings. These secrets can be preserved within a TEE, ensuring that they never get exposed to software that is outside of the TEE. Operations involving these secrets can be performed within the TEE, removing the need to ever extract the secrets outside of the TEE. Another example is the processing of data with privacy concerns. This is often the case in financial, healthcare and artificial intelligence (AI) applications. Putting sensitive operations inside a TEE allows organizations to support business processes without compromising the privacy expectations of their customers.</p>
<h3 id="intel-software-guard-extensions">Intel Software Guard Extensions</h3>
<p>Intel Software Guard Extensions (SGX) is an Intel platform security feature that implements the TEE paradigm. A portion of RAM called EPC (Enclave Page Cache) is used by applications to load secure isolated areas called SGX enclaves. Code and data inside SGX enclaves are encrypted and only decrypted inside the Intel CPU. From the host application perspective, an SGX enclave looks like a dynamic library. Any part of the application that is not contained in an SGX enclave is considered untrusted while the SGX enclave is considered trusted. Communications between the untrusted part and the trusted part (the SGX enclave) of an application uses a special calls called ECALLS and call from the enclave to the untrusted part of the application use OCALLS. A signed claim called SGX quote can be generated for an enclave. The SGX quote may contain a measurement of the code and the data of the enclave. An SGX quote allows to prove to a remote verifier (relying party) that an application includes the expected SGX enclave.</p>
<h4 id="sgx-ecdsa-attestation">SGX ECDSA Attestation</h4>
<p>SGX ECDSA attestation is the process that allows an application (relying party) to verify that a remote piece of code and data that it's interacting with is contained in a genuine Intel SGX enclave. The remote enclave can generate a signed claim called an SGX quote. A valid SGX quote signature generated on an SGX enabled platform can be chained up to a trusted Intel signing key. The SGX quote contains the measurement of the enclave (MREnclave), the enclave developer's signature (MRSigner), the security patch level of the platform (Trusted Computing Base or TCB) and any user data that the enclave wants to include in the quote. Typically, the user data in an SGX quote contains the hash of the public key part of a public/private key pair generated inside the enclave. The public key is transferred along with the SGX quote to the relying party. The latter generates a Symmetric Wrapping Key (SWK) and wraps it with the public key of the enclave. The wrapped SWK is provisioned into the SGX enclave, which can unwrap it since it has the corresponding private key. The relying party can then provision secrets into the SGX enclave after wrapping them with the SWK. For an enclave to generate an SGX quote, a PCK certificate for the host platform must be obtained from Intel SGX Provisioning Certification Service (PCS).</p>
<h4 id="pck-certificates-provisioning">PCK Certificates Provisioning</h4>
<p>To generate an SGX quote for an enclave, a PCK certificate must be obtained from SGX Provisioning Certification Service (PCS). Requiring a workload to retrieve the PCK certificate from Intel PCS at the time of the SGX quote generation can be detrimental to the workload. Network connectivity issues can prevent the connection to Intel PCS. To remove the dependency on network connectivity, the PCK certificates of the data center platforms are fetched before running any workload. This is achieved by extracting SGX related information from the platform using the PCK ID Retrieval tool and pushing it to a Caching Service running in the same data center. The Caching Service then retrieves the PCK certificates of all the platforms that pushed SGX information to it from Intel PCS. Network connectivity issues are not a problem since the Caching Service can retry if needed. When an SGX workload needs its PCK certificate, it can just get it from the Caching Service.</p>
<h2 id="key-protection">Key Protection</h2>
<p>Cryptographic keys are high value assets that must be protected against disclosure and corruption. Key disclosure or corruption expose the key owner to data confidentiality breaches, impersonation and denial of service. The industry has good solutions to protect keys at rest.</p>
<p>A popular solution is to store keys in a central secure Key Management System (KMS), and applications retrieve them at runtime. However, this solution does not protect keys once they are in RAM and used to perform cryptographic operations. Keys in RAM can be disclosed because of software vulnerabilities like Heartbleed or because of memory snapshots. Therefore, keys are not protected in use. This concern can be addressed by having the application send the payload that needs cryptographic processing to the KMS where the processing happens instead. By doing this, the key is never exposed in RAM. However, this solution incurs an overhead caused by the network round trip to the KMS.</p>
<p>Another solution is to store keys in Hardware Security Modules (HSMs)</p>
<h3 id="hsm">HSM</h3>
<p>A Hardware Security Module or HSM is a separate hardware part that can be attached to a server. HSMs provide APIs to create and load keys. HSMs also support APIs to perform cryptographic operations using keys stored inside them. The typical flow for using an HSM is to create or load a key in the HSM in a secure environment then take the HSM to the server where the workload runs and attach it to this server. The application then performs cryptographic operations using the key inside the HSM. This ensures that the key is never exposed in RAM. Therefore, HSMs protect keys both at rest and in-use. The drawback with HSMs is that they can be a costly hardware add-on to the server, and they require physical access to the server to get attached to it (via the USB port for example).</p>
<p>Most HSMs support the PKCS#11 cryptographic programming interface.</p>
<h3 id="pkcs11">PKCS#11</h3>
<p>PKCS#11 is the standard cryptographic programming interface supported by HSMs. The PKCS#11 interface is defined using a C-style definition, but many languages support bindings exist. Although applications can directly use the PKCS#11 programming interface, most applications use other cryptographic interfaces like openssl. Fortunately, openssl supports a PKCS#11 engine mechanism that converts openssl calls to PKCS#11calls. This allows applications written against the openssl cryptographic interface to use an HSM supporting the PKCS#11 interface without code change. Popular applications that use openssl but can still use an HSM to protect the key include Nginx and Apache.</p>
<h2 id="features">Features</h2>
<h3 id="sgx-attestation-infrastructure">SGX Attestation Infrastructure</h3>
<p>The SGX Attestation Infrastructure allows to fetch PCK certificates and SGX collateral from Intel SGX Provisioning Certification Service (PCS). It makes the PCK certificates available to workloads that use the SKC Client, which allows them to generate SGX quotes. The SGX Attestation Infrastructure also includes components that perform the verification of SGX quotes.</p>
<h3 id="sgx-support-in-orchestrators">SGX Support in Orchestrators</h3>
<p>The SGX Attestation Infrastructure can optionally push the SGX information on compute nodes to cloud orchestrators so that SGX workloads (like SKC) can be scheduled on compute nodes that support SGX. Currently, the Kubernetes orchestrator is supported.</p>
<h3 id="key-protection_1">Key Protection</h3>
<p>SKC leverages the SGX Attestation Infrastructure to protect keys in an SGX enclave at rest and in use. Applications use the SKC Client -- a set of libraries -- to retrieves keys at runtime from KBS. KBS performs an SGX enclave attestation. If the attestation is successful, KBS generates a Symmetric Wrapping Key (SWK), wraps it with the enclave public key and provisions it into the enclave, which can unwrap it since it has the corresponding private key. Application can then be provisioned into the SGX enclave after being wrapped with the SWK. Application keys are therefore never exposed to any software outside of the enclave.</p>
<h1 id="sgx-attestation-infrastructure-and-skc-components">SGX Attestation Infrastructure and SKC Components</h1>
<p>The components documented in this section are used by the SGX Attestation Infrastructure and therefore by SKC, which leverages the SGX Attestation Infrastructure. Components that are exclusively used by SKC have (SKC Only) in the corresponding sub-section title.</p>
<h2 id="certificate-management-service">Certificate Management Service</h2>
<p>All the certificates used by SKC services and by the SGX Agent are issued by the Certificate Management Service (CMS). CMS has a root CA certificate and all the SKC services and the SGX Agent certificates chain up to the CMS root CA.</p>
<p>CMS is an infrastructure service and is shared with other Intel® SecL-DC components.</p>
<h2 id="authentication-and-authorization-service">Authentication and Authorization Service</h2>
<p>The authentication and authorization for all SKC services and the SGX Agent are centrally managed by the Authentication and Authorization Service (AAS).</p>
<p>AAS is an infrastructure service and is shared with other Intel® SecL-DC components.</p>
<h2 id="sgx-caching-service">SGX Caching Service</h2>
<p>The SGX Caching Service (SCS) allows to retrieve the PCK certificates of the data center server platforms from Intel SGX Provisioning Certification Service (PCS). SCS retrieves also platform models collateral. The collateral consists of the security patches (TCBInfo) that have been issued for Intel platform models. Finally, SCS retrieves the Certificate Revocation Lists (CRLs).</p>
<p>Since the Caching Service stores all the TCBInfo of all the platform models in the datacenter, the SGX Quote Verification Service (SQVS) uses it to determine the TCB status of the platforms in the data center.</p>
<p>The SKC Client retrieves its PCK certificate from the Caching Service when it generates an SGX quote.</p>
<p>SCS can be deployed in both Cloud Service Provider (CSP) and tenant environments. In the CSP environment, SCS is used to fetch PCK certificates for compute nodes in the data center. In the tenant environment, it's used to cache SGX collateral information used in verifying SGX quotes.</p>
<h2 id="sgx-host-verification-service">SGX Host Verification Service</h2>
<p>The SGX Host Verification Service (SHVS) collects the SGX information of all the compute nodes in a data center using the SGX Agent. The SGX information consists of SGX discovery information (SGX supported, SGX enabled, FLC enabled and EPC memory size) and SGX platform hardware and software information (Manifest file/encPPID, CPU SVN, ISV SVN, QEID, QEIdentity, PCEID).</p>
<p>SHVS pushes the SGX platform hardware and software information to the SGX Caching Service (SCS), which uses it to get the PCK certificates of the platform from Intel SGX Provisioning Certification Service (PCS). SHVS also uses SCS to determine if the platform is up to date on hardware and security patches (TCB).</p>
<h2 id="sgx-agent">SGX Agent</h2>
<p>The SGX Agent resides on physical servers and reports on platform SGX-related information to the SGX Host Verification Service (SHVS).</p>
<p>The SGX Agent supports 2 modes: orchestrator (default) and registration-only. In the registration-only mode, the compute nodes SGX information does not get pushed to orchestrators like Kubernetes. In both modes, the SGX attestation flow is supported.</p>
<h2 id="integration-hub">Integration Hub</h2>
<p>The Integration Hub (IHUB) allows to support SGX in Kubernetes and Open stack. IHUB pulls the list of hosts details from Kubernetes and then using the host information it pulls the SGX Data from SGX Host Verification Service and pushes it to Kubernetes. IHUB performs these steps on a regular basis so that the most recent SGX information about nodes is reflected in Kubernetes and Openstack. This integration allows Kubernetes and Openstack to schedule VMs and containers that need to run SGX workloads on compute nodes that support SGX. The SGX data that IHUB pushes to Kubernetes consists of SGX enabled/disabled, SGX supported/not supported, FLC enabled/not enabled, EPC memory size, TCB status up to date/not up to date and platform-data expiry time.</p>
<h2 id="key-broker-service-skc-only">Key Broker Service (SKC Only)</h2>
<p>The Key Broker Service (KBS) is typically deployed in the tenant environment, not the Cloud Service Provider (CSP) environment. KBS is effectively a policy compliance engine. Its job is to manage key transfer requests from SKC Clients, releasing keys only to those that meet policy requirements. A user admin can create and register keys in KBS. He can also create key policies and assign them to keys. A key policy specifies the conditions that the SKC Client must fulfill for keys that have the policy assigned to them to be released. Most of the information about an SKC Client is contained in the SGX quote that it sends to KBS. The SGX quote also contains a hash of the enclave's public key. KBS gets the public key along the quote so the hash in the quote allows to verify that the public key is genuine. If the SGX quote verification (attestation) is successful, KBS generates a Symmetric Wrapping Key (SWK), wraps it with the enclave public key and provisions it into the enclave, which can unwrap it since it has the corresponding private key. Application can then be provisioned into the SGX enclave after being wrapped with the SWK. Application keys are therefore never exposed to any software outside of the enclave. </p>
<p>KBS is shared with other Intel® SecL-DC components.</p>
<h2 id="sgx-quote-verification-service">SGX Quote Verification Service</h2>
<p>The SGX Quote Verification Service (SQVS) is typically deployed in the tenant environment, not the Cloud Service Provider (CSP) environment. SQVS performs the verification of SGX quotes on behalf of KBS. SQVS determines if the SGX quote signature is valid. It also determines if the SGX quote has been generated on a platform that is up to date on security patches (TCB). For the latter, SQVS uses the SGX Caching Service, which caches the SGX collateral information about Intel platform models. SQVS also parses the SGX quote and extracts the entities and returns them to KBS, which can then make additional policy decisions based on the values of the theses entities.</p>
<h2 id="the-workload-sgx-dependencies">The Workload SGX Dependencies</h2>
<p>This is a set of dependencies needed by SGX workloads. </p>
<h2 id="the-skc-client-skc-only">The SKC Client (SKC Only)</h2>
<p>The SKC Client refers to a suite of libraries that applications that require key protection must link with. It's comprised of the SKC Library, which is an Intel® SecL-DC component and the Intel Crypto Toolkit. the SKC Client uses the workload SGX dependencies component.  The SKC Library supports the PKCS#11 interface and is therefore considered as a PKCS#11 module from the host application perspective. The SKC Library uses Intel Crypto Toolkit to protect keys in an SGX enclave. When a key is requested by the host application, the SKC Library sends a request to the Key Broker Service (KBS) along with an SGX quote that is generated by the Crypto Toolkit. KBS releases the key after verifying the quote and evaluating the attributes contained in the quote. The key policy can also specify conditions that can't be verified with the SGX quote alone.</p>
<p>The SKC Client is typically deployed inside a tenant VM or container. It can also be used on bare metal. In all these deployments, the underlying platform is typically owned by a Cloud Service Provider (CSP) and is considered untrusted.</p>
<h1 id="definitions-acronyms-and-abbreviation">Definitions, Acronyms, and Abbreviation</h1>
<p>SKC -- Secure Key Caching</p>
<p>SGX -- Software Guard Extension</p>
<p>TEE -- Trusted Execution Environment</p>
<p>HSM -- Hardware Security Module</p>
<p>KBS -- Key Broker Service</p>
<p>CSP -- Cloud Service Provider</p>
<p>TEE -- Trusted Execution Environment</p>
<p>PCS -- Provisioning Certification Service</p>
<p>CRLs -- Certificate Revocation Lists </p>
<p>AAS -- Authentication and Authorization Service</p>
<p>SWK -- Symmetric Wrapping Key</p>
<p>CRDs -- Custom Resource Definitions </p>
<h1 id="architecture-overview">Architecture Overview</h1>
<p>As indicated in the Features section, SKC provides 3 features essentially:</p>
<ul>
<li>SGX Attestation Support: this is the feature that CSPs provide to tenants who need to run SGX workloads that require attestation.</li>
<li>
<p>SGX Support  in Orchestrators: this feature allows to discover SGX support in physical servers and related information:</p>
<ul>
<li>
<p>SGX supported.</p>
</li>
<li>
<p>SGX enabled.</p>
</li>
<li>
<p>Size of RAM reserved for SGX. It's called Enclave Page Cache (EPC).</p>
</li>
<li>
<p>Flexible Launch Control enabled.</p>
</li>
<li>Key Protection: this is the feature used by tenants using a CSP to run workloads with key protection requirements.</li>
</ul>
</li>
</ul>
<p>The high-level architectures of these features are presented in the next sub-sections.</p>
<h2 id="sgx-attestation-support-and-sgx-support-in-orchestrators">SGX Attestation Support and SGX Support in Orchestrators</h2>
<p>The diagram below shows the infrastructure that CSPs need to deploy to support SGX attestation and optionally, integration with orchestrators (currently only Kubernetes is supported). </p>
<p>The SGX Agent supports 2 modes: orchestrator (default) and registration-only. In the registration-only mode, the compute nodes SGX information does not get pushed to orchestrators like Kubernetes. In both modes, the SGX attestation flow is supported. </p>
<p>In the orchestrator mode, the SGX Agent is registered to the SGX Host Verification Service (SHVS) at installation time. At runtime, SHVS pulls the SGX platform information from the SGX Agent, which gets the SGX information from the platform directly. SHVS then pushes the information to the SGX Caching Service (SCS), which uses it to get the PCK Certificate and other SGX collateral from the Intel SGX Provisioning Certification Service (PCS) and caches them locally. When a workload on the platform needs to generate an SGX Quote, it retrieves the PCK Certificate of the platform from SCS.</p>
<p>In the orchestrator mode, the platform information is made available to Kubernetes via the SGX Hub (IHUB), which pulls it from SHVS and pushes it to the Kubernetes Master using Custom Resource Definitions (CRDs).</p>
<p>In the registration-only mode, the SGX Agent pushes the SGX information directly to the SGX Caching Service and SHVS is not involved in the flow. PCK certificates are obtained and made available to workloads the same way as in the in the orchestrator mode. </p>
<p>The SGX Quote Verification Service (SQVS) allows attesting applications to verify SGX quotes and extract the SGX quote attributes to verify compliance with a user-defined SGX enclave policy. SQVS uses the SGX Caching Service to retrieve SGX collateral needed to verify SGX quotes from the Intel SGX Provisioning Certification Service (PCS). SQVS typically runs in the the attesting application owner network environment. Typically, a separate instance of the SGX Caching Service is set setup in the attesting application owner network environment. </p>
<p><img alt="" src="../Images/image-20200727163158892.png" /></p>
<p>The SGX Agent and the SGX services integrate with the Authentication and Authorization Service (AAS) and the Certificate Management Service (CMS). AAS and CMS are not represented on the diagram for clarity.</p>
<h2 id="key-protection_2">Key Protection</h2>
<p>Key Protection leverages the SGX Attestation support and optionally, the SGX support in orchestrators.</p>
<p>Key Protection is implemented by the SKC Client -- a set of libraries - which must be linked with a tenant workload, like Nginx, deployed in a CSP environment and the Key Broker Service (KBS) deployed in the tenant's enterprise environment. The SKC Client retrieves the keys needed by the workload from KBS after proving that the key can be protected in an SGX enclave as shown in the diagram below.</p>
<p><img alt="" src="../Images/image-20200727163116765.png" /></p>
<p>Step 6 is optional (keys can be stored in KBS). Keys policies in step 2 are called Key Transfer Policies and are created by an Admin and assigned to Application keys.</p>
<h1 id="intel-security-libraries-installation">Intel® Security Libraries Installation</h1>
<h2 id="building-from-source">Building from Source</h2>
<p>Intel® Security Libraries is distributed as open source code and must be compiled into installation binaries before installation.</p>
<p>Instructions and sample scripts for building the Intel® SecL-DC components can be found here (Section 1 to 7)</p>
<p><a href="https://github.com/intel-secl/docs/blob/v3.3.1/develop/quick-start-guides/Quick%20Start%20Guide%20-%20Intel%C2%AE%20Security%20Libraries%20-%20Secure%20Key%20Caching.md">https://github.com/intel-secl/docs/blob/v3.3.1/develop/quick-start-guides/Quick%20Start%20Guide%20-%20Intel%C2%AE%20Security%20Libraries%20-%20Secure%20Key%20Caching.md</a></p>
<p>After the components have been built, the installation binaries can be found in the binaries directory created by the build scripts.</p>
<p>For components written in GO (Authentication and Authorization Service, Certificate Management Service, SGXAgent, Integration HUB, Key Broker Service, SGX Caching Service, SGX Quote Verfication Service, SGX Host Verification Service):</p>
<p>\&lt;servicename>/out/\&lt;servicename>.bin</p>
<p>In addition, the build script will produce some sample database scripts that can be used during installation to setup postgres and create database.</p>
<p>Install_pgdb: intel-secl/deployments/installer/install_pgdb.sh</p>
<p>Install_pgscsdb: sgx-caching-service/out/install_pgscsdb.sh</p>
<p>Install_pgshvsdb: sgx-hvs/out/install_pgshvsdb.sh</p>
<h2 id="hardware-considerations">Hardware Considerations</h2>
<h3 id="supported-hardware">Supported <strong>Hardware</strong></h3>
<ul>
<li>Intel® Xeon® SP products those support SGX</li>
</ul>
<h3 id="bios-requirements">BIOS Requirements</h3>
<ul>
<li>
<p>Intel® SGX-TEM BIOS requirements are outlined in the latest Intel® SGX Platforms BIOS Writer's Guide</p>
</li>
<li>
<p>Intel® SGX should be enabled in BIOS menu (Intel® SGX is Disabled by default on Ice Lake).</p>
</li>
<li>
<p>Intel® SGX BIOS requirements include exposing Flexible Launch Control menu.</p>
</li>
</ul>
<h3 id="os-requirements-intel-sgx-does-not-supported-on-32-bit-os">OS Requirements (Intel® SGX does not supported on 32-bit OS):</h3>
<ul>
<li>Linux*:\
    • RHEL 8.2</li>
</ul>
<h2 id="recommended-service-layout">Recommended Service Layout</h2>
<p>The Intel® SecL-DC services can be installed in a variety of layouts, partially depending on the use cases desired and the OS of the server(s) to be protected. In general, the Intel® SecL-DC applications can be divided into management services that are deployed on the network on the management plane, and host or node components that must be installed on each protected server.</p>
<p>Management services can typically be deployed anywhere with network access to all the protected servers. This could be a set of individual VMs per service; containers; or all installed on a single physical or virtual machine.</p>
<p>Node components must be installed on each protected physical server.</p>
<p>Typically, this is needed for Linux deployments.</p>
<p>For a POC environment, all the management services can be installed on a single machine or VM.</p>
<p>This Includes:</p>
<ul>
<li>
<p>Certificate Management Service (CMS)</p>
</li>
<li>
<p>Authentication and Authorization Service (AAS)</p>
</li>
<li>
<p>SGX Caching Service (SCS)</p>
</li>
<li>
<p>SGX Host Verification Service (SHVS)</p>
</li>
<li>
<p>Integration HUB (IHUB)</p>
</li>
<li>
<p>Key Broker Service (KBS) with backend key management</p>
</li>
<li>
<p>SGX Quote Verification Service (SQVS)</p>
</li>
</ul>
<p>SGX Agent &amp; SKC Library needs to be installed on SGX Enabled Machine.</p>
<p>The node components (SGX Agent) must be installed on each protected physical server:</p>
<h3 id="using-the-provided-database-installation-script">Using the provided Database Installation Script</h3>
<p>Install a sample Postgresql 11 database using the script provided in corresponding component. This script will automatically install the Postgresql database and client packages required.</p>
<p>Create the iseclpgdb.env answer file:</p>
<p>ISECL_PGDB_IP_INTERFACES=localhost</p>
<p>ISECL_PGDB_PORT=5432</p>
<p>ISECL_PGDB_SAVE_DB_INSTALL_LOG=true</p>
<p>ISECL_PGDB_CERT_DNS=localhost</p>
<p>ISECL_PGDB_CERT_IP=127.0.0.1</p>
<p>ISECL_PGDB_DBNAME=aasdb</p>
<p>ISECL_PGDB_USERNAME=aasdbuser</p>
<p>ISECL_PGDB_USERPASSWORD=aasdbpassword</p>
<p>Note that the values above assume that the database will be accessed locally. If the database server will be external to the Intel® SecL services, change these values to the hostname or FQDN and IP address where the client will access the database server.</p>
<h3 id="provisioning-the-database">Provisioning the Database</h3>
<p>Each Intel® SecL service that uses a database (the Authentication and Authorization Service, the SGX host Verification Service, the SGX caching Service,) requires its own schema and access. The database must be created and initialized. Execute the install_pg(app name).sh script to configure the database.</p>
<p>If a single shared database server will be used for each Intel® SecL service (for example, if all management plane services will be installed on a single VM), run the script multiple times, once for each service that requires a database.</p>
<p>If separate database servers will be used (for example, if the management plane services will reside on separate systems and will use their own local database servers), execute the script on each server hosting a database. The database install scripts use default configuration</p>
<p>AAS: install_pgdb.sh</p>
<p>SCS: install_pgscsdb.sh</p>
<p>SHVS: install_pgshvsdb.sh</p>
<p>Note the dbusername and password will be taken from respective component environment files.</p>
<h3 id="database-server-tls-certificate">Database Server TLS Certificate</h3>
<p>The database client for Intel® SecL services requires the database TLS certificate to authenticate communication with the database server.</p>
<p>If the database server for a service is located on the same server that the service will run on, only the path to this certificate is needed. If the provided Postgres scripts are used, the certificate will be in /usr/local/pgsql/data/server.crt.</p>
<p>If the database server will be run separately from the Intel® SecL service(s), the certificate will need to be copied from the database server to the service machine before installing the Intel® SecL services.</p>
<p>The database client for Intel® SecL services will validate that the Subject Alternative Names in the database server's TLS certificate contain the hostname(s)/IP address(es) that the clients will use to access the database server. If configuring a database without using the provided scripts, ensure that these attributes are present in the database TLS certificate.</p>
<h2 id="installing-the-certificate-management-service">Installing the Certificate Management Service</h2>
<h3 id="required-for">Required For</h3>
<p>The CMS is REQUIRED for all use cases.</p>
<h3 id="supported-operating-system">Supported Operating System</h3>
<p>The Intel® Security Libraries Certificate Management Service supports Red Hat Enterprise Linux 8.2.</p>
<h3 id="recommended-hardware">Recommended Hardware</h3>
<ul>
<li>
<p>1 vCPUs</p>
</li>
<li>
<p>RAM: 2 GB</p>
</li>
<li>
<p>10 GB</p>
</li>
<li>
<p>One network interface with network access to all Intel® SecL-DC services</p>
</li>
</ul>
<h3 id="installation">Installation</h3>
<p>To install the Intel® SecL-DC Certificate Management Service:</p>
<ol>
<li>
<p>Copy the Certificate Management Service installation binary to the /root/ directory.</p>
</li>
<li>
<p>Create the cms.env installation answer file for an unattended installation:</p>
</li>
</ol>
<p>AAS_TLS_SAN=\&lt; Comma-Separated list of IPs and hostnames for the AAS></p>
<p>AAS_API_URL=https://\&lt; Authentication and Authorization Service IP or Hostname>:8444/aas</p>
<p>SAN_LIST=\&lt; Comma-Separated list of IP addresses and hostnames for the CMS></p>
<p>The SAN list will be used to authenticate the Certificate Signing Request from the AAS to the CMS. Only a CSR originating from a host matching the SAN list will be honored. Later, in the AAS authservice.env installation answer file, this same SAN list will be provided for the AAS installation. These lists must match and must be valid for IPs and/or hostnames used by the AAS system. The SAN list variables also accept the wildcards "?" (for single-character wildcards) and "*" (for multiple-character wildcards) to allow address ranges or multiple FQDNs.</p>
<p>The AAS_API_URL represents the URL for the AAS that will exist after the AAS is installed.</p>
<p>For all configuration options and their descriptions, refer to the Intel® SecL Configuration section on the Certificate Management Service.</p>
<ol>
<li>Execute the installer binary.</li>
</ol>
<p>./cms-v3.3.1.bin</p>
<p>When the installation completes, the Certificate Management Service is available. The services can be verified by running cms status from the command line.</p>
<p># cms status</p>
<p>After installation is complete, the CMS will output a bearer token to the console. This token will be used with the AAS during installation to authenticate certificate requests to the CMS. If this token expires or otherwise needs to be recreated, use the following command:</p>
<p>cms setup cms_auth_token --force</p>
<p>In addition, the SHA384 digest of the CMS TLS certificate will be needed for installation of the remaining Intel® SecL services. The digest can be obtained using the following command:</p>
<p>cms tlscertsha384</p>
<h2 id="installing-the-authentication-and-authorization-service">Installing the Authentication and Authorization Service</h2>
<h3 id="required-for_1">Required For</h3>
<p>The AAS is REQUIRED for all use cases.</p>
<h3 id="prerequisites">Prerequisites</h3>
<p>The following must be completed before installing the Authentication and Authorization Service:</p>
<ul>
<li>
<p>The Certificate Management Service must be installed and available</p>
</li>
<li>
<p>The Authentication and Authorization Service database must be available</p>
</li>
</ul>
<h3 id="package-dependencies">Package Dependencies</h3>
<p>The Intel® SecL-DC Authentication and Authorization Service (AAS) requires a Postgresql 11 database. A script (install_pgdb.sh) is provided with the AAS that will automatically add the Postgresql repositories and install/configure a sample database. If this script will not be used, a Postgresql 11 database must be installed by the user before executing the AAS installation.</p>
<h3 id="supported-operating-systems">Supported Operating Systems</h3>
<p>The Intel® Security Libraries Authentication and Authorization Service supports Red Hat Enterprise Linux 8.2.</p>
<h3 id="recommended-hardware_1">Recommended Hardware</h3>
<ul>
<li>
<p>1 vCPUs</p>
</li>
<li>
<p>RAM: 2 GB</p>
</li>
<li>
<p>10 GB</p>
</li>
<li>
<p>One network interface with network access to all Intel® SecL-DC services</p>
</li>
</ul>
<h3 id="installation_1">Installation</h3>
<p>Before AAS is installed, Database needs to be created. Use the following commands to install postgres and create AAS DB</p>
<p>dnf -y install <a href="https://download.postgresql.org/pub/repos/yum/reporpms/EL-8-x86_64/pgdg-redhat-repo-latest.noarch.rpm">https://download.postgresql.org/pub/repos/yum/reporpms/EL-8-x86_64/pgdg-redhat-repo-latest.noarch.rpm</a></p>
<p>dnf module disable postgresql -y</p>
<p>copy install_pgdb.sh and create_db.sh to /root/ directory</p>
<p>./install_pgdb.sh</p>
<p>./create_db.sh aasdb <db_user> <db_password></p>
<p>To install the AAS, a bearer token from the CMS is required. This bearer token is output at the end of the CMS installation. However, if a new token is needed, simply use the following command from the CMS command line:</p>
<p>cms setup cms_auth_token --force</p>
<p>Create the authservice.env installation answer file in /root/ directory as below:</p>
<pre><code>  CMS_BASE_URL=https://&lt; CMS IP or hostname&gt;:8445/cms/v1/

  CMS_TLS_CERT_SHA384=&lt;CMS TLS certificate sha384&gt;

  AAS_DB_SSLMODE=verify-full

  AAS_DB_HOSTNAME=&lt;IP or hostname of database server&gt;

  AAS_DB_PORT=&lt;database port number; default is 5432&gt;

  AAS_DB_NAME=&lt;database name&gt;

  AAS_DB_USERNAME=&lt;database username&gt;

  AAS_DB_PASSWORD=&lt;database password&gt;

  AAS_DB_SSLCERTSRC=&lt;path to database TLS certificate; the default location is typically /usr/local/pgsql/data/server.crt&gt;

  AAS_ADMIN_USERNAME=&lt;username for AAS administrative user&gt;

  AAS_ADMIN_PASSWORD=&lt;password for AAS administrative user&gt;

  AAS_JWT_TOKEN_DURATION_MINS=2880

  SAN_LIST=&lt;comma-separated list of IPs and hostnames for the AAS; this should match the value for the AAS_TLS_SAN in the cms.env file from the CMS installation&gt;

  BEARER_TOKEN=&lt;bearer token from CMS installation&gt;
</code></pre>
<p>Execute the AAS installer:</p>
<p>./authservice-v3.3.1.bin</p>
<p>Note: the AAS_ADMIN credentials specified in this answer file will have administrator rights for the AAS and can be used to create other users, create new roles, and assign roles to users.</p>
<h3 id="creating-users">Creating Users</h3>
<p>Before deployment is initiated, user account and roles must be generated for each component.  Most of these accounts will be service users, used by the various Intel® SecL SKC services to work together.</p>
<p>Creating these required users and roles is facilitated by the scripts in the corresponding components (Refer to dist/linux directory of each component) and needs to be executed before installation of each component.</p>
<p>SCS: scs_aas_curl.sh</p>
<p>SHVS: shvs_aas_curl.sh</p>
<p>SQVS: sqvs_aas_curl.sh</p>
<p>For Key Broker Service and Integration Hub User/Roles creation, Please refer to the appendix section for sample scripts</p>
<p>The output of these scripts is a bearer-token which needs to be updated in the BEARER_TOKEN env variable in the corresponding component’s env file.</p>
<h2 id="installing-the-caching-service">Installing the Caching Service</h2>
<h3 id="required-for_2">Required For</h3>
<p>The SCS is REQUIRED for the following use cases.</p>
<h3 id="prerequisites-csp-enterprise">Prerequisites (CSP &amp; Enterprise)</h3>
<p>The following must be completed before installing the SGX Caching Service</p>
<ul>
<li>
<p>The Certificate Management Service must be installed and available</p>
</li>
<li>
<p>The Authentication and Authorization Service must be installed and available</p>
</li>
<li>
<p>User needs to subscribe to Intel\'s Provisioning Certificate Service to obtain an API Key</p>
</li>
<li>
<p>The SGX Caching Service database must be available</p>
</li>
</ul>
<h3 id="package-dependencies_1">Package Dependencies</h3>
<p>The Intel® SecL-DC SGX Caching Service (SCS) requires a</p>
<p>Postgresql 11 database. A script (install_pgscsdb.sh) is provided with the SCS</p>
<p>that will automatically add the Postgresql repositories and install/configure a</p>
<p>sample database. If this script will not be used, a Postgresql 11 database</p>
<p>must be installed by the user before executing the SCS installation.</p>
<h3 id="supported-operating-system_1">Supported Operating System</h3>
<p>The Intel® Security Libraries SGX Caching Service supports Red Hat Enterprise Linux 8.2.</p>
<h3 id="recommended-hardware_2">Recommended Hardware</h3>
<ul>
<li>
<p>4 vCPUs</p>
</li>
<li>
<p>RAM: 8 GB</p>
</li>
<li>
<p>100 GB</p>
</li>
<li>
<p>One network interface with network access to all managed servers. Internet connection is needed for connecting to Intel PCS Server.</p>
</li>
</ul>
<h3 id="installation_2">Installation</h3>
<p>Before SCS is installed, Database needs to be created. Use the following commands to install postgres and create SCS DB</p>
<p>copy install_pgscsdb.sh to /root/ directory</p>
<p>Open ~/iseclpgdb.env and update the ISECL_PGDB_DBNAME with SCS db name, ISECL_PGDB_USERNAME with SCS db username and ISECL_PGDB_USERPASSWORD with SCS db password</p>
<p>./install_pgscsdb.sh</p>
<ol>
<li>
<p>Copy the SCS installation binary to the /root/ directory.</p>
</li>
<li>
<p>Create the scs.env installation answer file in /root/ directory as below:</p>
<p>SCS_DB_USERNAME=<database username></p>
<p>SCS_DB_PASSWORD=<database password></p>
<p>SCS_DB_HOSTNAME=<IP or hostname of database server></p>
<p>SCS_DB_PORT=<Database port; 5432 by default></p>
<p>SCS_DB_NAME=<name of the SCS database; pgscsdb by default></p>
<p>SCS_DB_SSLCERTSRC=<path to database TLS certificate; the default location is typically /usr/local/pgsql/data/server.crt></p>
<p>INTEL_PROVISIONING_SERVER=<hostname of INTEL PCS Server></p>
<p>INTEL_PROVISIONING_SERVER_API_KEY=<subscription key></p>
<p>SCS_REFRESH_HOURS=<time in hours to refresh SGX collaterals; 1 hour by default></p>
<p>SCS_ADMIN_USERNAME=<username for SCS service account></p>
<p>SCS_ADMIN_PASSWORD=<password for SCS service account></p>
<p>CMS_BASE_URL=https://<IP or hostname to CMS>:8445/cms/v1/</p>
<p>CMS_TLS_CERT_SHA384=<sha384 of CMS TLS certificate></p>
<p>AAS_API_URL=https://<IP or hostname to AAS>:8444/aas</p>
<p>RETRY_COUNT=3</p>
<p>WAIT_TIME=1</p>
<p>SAN_LIST=<comma-separated list of IPs and hostnames for the SCS></p>
<p>BEARER_TOKEN=<Installation token from AAS> </p>
</li>
</ol>
<p>BEARER_TOKEN above can be obtained from running scs_aas_curl.sh script below</p>
<p>Execute scs_aas_curl.sh script to create SGX Caching Service user account and roles</p>
<p>cd sgx-caching-service/dist/linux/</p>
<p>./scs_aas_curl.sh</p>
<p>Update the BEARER_TOKEN value in /root/scs.env file</p>
<p>Execute the SCS installer binary:</p>
<p>./scs-v3.3.1.bin</p>
<h2 id="installing-the-sgx-host-verification-service">Installing the SGX Host Verification Service</h2>
<h3 id="required-for_3">Required For</h3>
<p>The SGX Host Verification Service is REQUIRED in the default orchestrator SGX Agent mode.  </p>
<h3 id="prerequisites_1">Prerequisites</h3>
<p>The following must be completed before installing the SGX Host Verification Service:</p>
<ul>
<li>
<p>The Certificate Management Service must be installed and available</p>
</li>
<li>
<p>The Authentication and Authorization Service must be installed and available</p>
</li>
<li>
<p>The SGX Host Verification Service database must be available</p>
</li>
</ul>
<h3 id="package-dependencies_2">Package Dependencies</h3>
<p>The Intel® Security Libraries SGX Host Verification Service requires the following packages and their dependencies:</p>
<ul>
<li>
<p>Postgres* client and server 11.6 (server component optional if an external Postgres database is used)</p>
</li>
<li>
<p>Golang packages</p>
</li>
</ul>
<p>If they are not already installed, the SGX Host Verification Service installer attempts to install these automatically using the package manager. Automatic installation requires access to package repositories (the RHEL subscription repositories, the EPEL repository, or a suitable mirror), which may require an Internet connection. If the packages are to be installed from the package repository, be sure to update the repository package lists before installation.</p>
<h3 id="supported-operating-systems_1">Supported Operating Systems</h3>
<p>The Intel® Security Libraries SGX Host Verification Service supports Red Hat Enterprise Linux 8.2.</p>
<h3 id="recommended-hardware_3">Recommended Hardware</h3>
<ul>
<li>
<p>4 vCPUs</p>
</li>
<li>
<p>RAM: 8 GB</p>
</li>
<li>
<p>100 GB</p>
</li>
<li>
<p>One network interface with network access to all managed servers</p>
</li>
</ul>
<h3 id="installation_3">Installation</h3>
<p>Before SHVS is installed, Database needs to be created. Use the following commands to install postgres and create SHVS DB</p>
<p>copy install_pgshvsdb.sh to /root/ directory</p>
<p>Open ~/iseclpgdb.env and update the ISECL_PGDB_DBNAME with SHVS db name, ISECL_PGDB_USERNAME with SHVS db username and ISECL_PGDB_USERPASSWORD with SHVS db password</p>
<p>./install_pgshvsdb.sh</p>
<p>To install the SGX Host Verification Service, follow these steps:</p>
<ul>
<li>
<p>Copy the SGX Host Verification Service installation binary to the /root/ directory.</p>
</li>
<li>
<p>Create the shvs.env installation answer file in /root/ directory as below.</p>
</li>
</ul>
<p>A sample minimal shvs.env file is provided below. For all configuration options and their descriptions, refer to the Intel® SecL Configuration section on the SGX Host Verification Service.</p>
<pre><code> SHVS_DB_HOSTNAME=&lt;hostname or IP address to database server&gt;

 SHVS_DB_USERNAME=&lt;Database administrative username&gt;

 SHVS_DB_PORT=&lt;Database port, default is 5432&gt;

 SHVS_DB_PASSWORD=&lt;Database password&gt;

 SHVS_DB_NAME=&lt;Database schema&gt;

 SHVS_ADMIN_USERNAME=&lt;SGX Host Verification Service username&gt;

 SHVS_ADMIN_PASSWORD=&lt;SGX HostVerification Service password&gt;

 CMS_TLS_CERT_SHA384=&lt;Certificate Management Service TLS digest&gt;

 SHVS_DB_SSLCERTSRC=/usr/local/pgsql/data/server.crt

 SHVS_SCHEDULER_TIMER=10

 SHVS_HOST_PLATFORM_EXPIRY_TIME=4

 SHVS_AUTO_REFRESH_TIMER=120

 BEARER_TOKEN=&lt;Installation token from AAS&gt;

 AAS_API_URL=https://&lt;Authentication and Authorization Service IP or Hostname&gt;:8444/aas

 CMS_BASE_URL=https://&lt;Certificate Management Service IP or Hostname&gt;:8445/cms/v1/

 SCS_BASE_URL=https://&lt;SGX Caching Service IP or Hostname&gt;:9000/scs/sgx/

 SAN_LIST=&lt;Comma-separated list of IP addresses and hostnames for the SHVS&gt;
</code></pre>
<p>BEARER_TOKEN above can be obtained from running shvs_aas_curl.sh script below</p>
<p>Execute shvs_aas_curl.sh script to create SGX Host Verification Service user account and roles</p>
<p>cd sgx-hvs/dist/linux/</p>
<p>./shvs_aas_curl.sh</p>
<p>Update the BEARER_TOKEN value in /root/shvs.env file</p>
<p>Execute the installer binary.</p>
<p>./shvs-v3.3.1.bin</p>
<p>When the installation completes, the SGX Host Verification Service is available. The service can be verified by running <strong>shvs</strong> status from the SGX Host Verification Service command line.</p>
<p># shvs status</p>
<h2 id="installing-the-sgx-agent">Installing the SGX Agent</h2>
<h3 id="required-for_4">Required for</h3>
<p>The SGX Agent is REQUIRED for all use cases. </p>
<p>The SGX Agent supports 2 modes: orchestrator (default) and registration-only. In the registration-only mode, the compute nodes SGX information does not get pushed to orchestrators like Kubernetes. In both modes, the SGX attestation flow is supported. </p>
<p>In the orchestrator mode, SGX Agent is registered with SGX Host Verification Service (SHVS), which then pulls all SGX platform data. SHVS, in turn, pushes the data to the SGX Caching Service (SCS).</p>
<p>In the registration-only mode, the SGX Agent pushes the SGX platform data directly to SCS and SHVS is not involved in the flow. </p>
<h3 id="prerequisites_2">Prerequisites</h3>
<ul>
<li>
<p>The following must be completed before installing the SGX Agent:</p>
<ul>
<li>Certificate Management Service, Authentication and Authorization Service,SGX Caching Service and SGX Host Verification Service must be installed and available.</li>
</ul>
</li>
</ul>
<h3 id="package-dependencies_3">Package Dependencies</h3>
<p>The Intel® Security Libraries SGX Agent Service requires the following packages and their dependencies:</p>
<ul>
<li>Golang packages</li>
</ul>
<h3 id="supported-operating-systems_2">Supported Operating Systems</h3>
<p>Red Hat Enterprise Linux 8.2.</p>
<p><strong>Recommended Hardware</strong></p>
<p>Intel® Xeon® SP (Ice Lake-SP)</p>
<h3 id="installation_4">Installation</h3>
<pre><code>Copy sgx_agent.tar sgx_agent.sha2 and agent_untar.sh to a directory on SGX Compute node
./agent_untar.sh
Update the following in agent.conf
 - IP address for all the services
 - Certificate Management Service TLS digest value (CMS running on CSP system)
./deploy_sgx_agent.sh
</code></pre>
<h2 id="installing-the-sqvs">Installing the SQVS</h2>
<h3 id="required-for_5">Required for</h3>
<p>SGX ECDSA Attestation / SGX Quote Verification by KBS</p>
<h3 id="prerequisites_3">Prerequisites</h3>
<ul>
<li>
<p>The following must be completed before installing the SQVS:</p>
<ul>
<li>Certificate Management Service, Authentication and Authorization Service and SGX Caching Service must be installed and available.</li>
</ul>
</li>
</ul>
<h3 id="package-dependencies_4">Package Dependencies</h3>
<p>The Intel® Security Libraries Quote Verification Service requires the following packages and their dependencies:</p>
<ul>
<li>Golang packages</li>
</ul>
<h3 id="supported-operating-systems_3">Supported Operating Systems</h3>
<p>Red Hat Enterprise Linux 8.2.</p>
<h3 id="recommended-hardware_4">Recommended Hardware</h3>
<ul>
<li>
<p>4 vCPUs</p>
</li>
<li>
<p>RAM: 8 GB</p>
</li>
<li>
<p>100 GB</p>
</li>
<li>
<p>One network interface with network access to all managed servers</p>
</li>
</ul>
<h3 id="installation_5">Installation</h3>
<p>To install the SQVS Service, follow these steps:</p>
<ol>
<li>
<p>Copy the SQVS installation binary to the ~/root directory</p>
</li>
<li>
<p>Create the sqvs.env installation answer file in /root/ directory as below</p>
</li>
</ol>
<p>A sample minimal sqvs.env file is provided below. For all configuration options and their descriptions, refer to the Configuration section on the SGX Quote Verification Service.</p>
<pre><code>   SGX_TRUSTED_ROOT_CA_PATH=&lt; Path where trusted root ca cert for PCS is stored, by default /tmp/trusted_rootca.pem &gt;

   SCS_BASE_URL=https://&lt; SCS IP or Hostname &gt;:9000/scs/sgx/certification/v1

   SQVS_USERNAME=&lt; SGX Quote Verification Service username &gt;

   SQVS_PASSWORD=&lt; SGX Quote Verification Service password &gt;

   CMS_TLS_CERT_SHA384=&lt; Certificate Management Service TLS digest &gt;

   BEARER_TOKEN=&lt; Installation token &gt;

   AAS_API_URL=https://&lt; Authentication and Authorization Service IP or Hostname &gt;:8444/aas

   CMS_BASE_URL=https://&lt; Certificate Management Service IP or Hostname &gt;:8445/cms/v1/

   SAN_LIST=&lt; *Comma-separated list of IP addresses and hostnames for the SQVS* &gt;

   SQVS_NOSETUP=false

   SQVS_PORT=12000

   SQVS_LOGLEVEL=info

   SQVS_INCLUDE_TOKEN=true
</code></pre>
<p>BEARER_TOKEN above can be obtained from running sqvs_aas_curl.sh script below</p>
<p>Execute sqvs_aas_curl.sh script to create SGX Verification Service user account and roles</p>
<p>cd sgx-verification-service/dist/linux/</p>
<p>./sqvs_aas_curl.sh</p>
<p>Update the BEARER_TOKEN value in /root/sqvs.env file</p>
<ol>
<li>Execute the sqvs installer binary.</li>
</ol>
<p>sqvs-v3.3.1.bin</p>
<p>When the installation completes, the SGX Quote Verification Service is available. The service can be verified by sqvs status from the sqvs command line.</p>
<p># sqvs status</p>
<h2 id="setup-k8s-cluster-deploy-isecl-k8s-extensions">Setup K8S Cluster &amp; Deploy Isecl-k8s-extensions</h2>
<ul>
<li>Setup master and worker node for k8s. Worker node should be setup on SGX host machine. Master node can be any VM machine.</li>
<li>Please note whatever hostname has been used on worker node while registering SGX_Agent with SHVS, use same node-name in join command.</li>
<li>Once the master/worker setup is done, follow below steps:</li>
</ul>
<h5 id="untar-packages-and-load-docker-images">Untar packages and load docker images</h5>
<ul>
<li>Copy tar output isecl-k8s-extensions-*.tar.gz from build VM binaries folder to /opt/ directory on the Master Node and extract the contents.</li>
</ul>
<div class="highlight"><pre><span></span><code>    cd /opt/
    tar -xvzf isecl-k8s-extensions-*.tar.gz
</code></pre></div>
<ul>
<li>Load the docker images</li>
</ul>
<div class="highlight"><pre><span></span><code>    cd isecl-k8s-extensions
    docker load -i docker-isecl-controller-v*.tar
    docker load -i docker-isecl-scheduler-v*.tar
</code></pre></div>
<h5 id="deploy-isecl-controller">Deploy isecl-controller</h5>
<ul>
<li>Create hostattributes.crd.isecl.intel.com crd</li>
</ul>
<div class="highlight"><pre><span></span><code>    kubectl apply -f yamls/crd-1.17.yaml
</code></pre></div>
<ul>
<li>Check whether the crd is created</li>
</ul>
<div class="highlight"><pre><span></span><code>    kubectl get crds
</code></pre></div>
<ul>
<li>Deploy isecl-controller</li>
</ul>
<div class="highlight"><pre><span></span><code>    kubectl apply -f yamls/isecl-controller.yaml
</code></pre></div>
<ul>
<li>Check whether the isecl-controller is up and running</li>
</ul>
<div class="highlight"><pre><span></span><code>    kubectl get deploy -n isecl
</code></pre></div>
<ul>
<li>Create clusterrolebinding for ihub to get access to cluster nodes</li>
</ul>
<div class="highlight"><pre><span></span><code>    kubectl create clusterrolebinding isecl-clusterrole --clusterrole=system:node --user=system:serviceaccount:isecl:isecl
</code></pre></div>
<ul>
<li>Fetch token required for ihub installation and follow below steps to update ihub.env,</li>
</ul>
<div class="highlight"><pre><span></span><code>    kubectl get secrets -n isecl
    kubectl describe secret default-token-&lt;name&gt; -n isecl
</code></pre></div>
<p>For IHUB installation, make sure to update below configuration in /root/binaries/env/ihub.env before installing ihub on CSP VM:</p>
<ul>
<li>Copy /etc/kubernetes/pki/apiserver.crt from master node to /root on CSP VM. Update KUBERNETES_CERT_FILE.</li>
<li>Get k8s token in master, using above commands and update KUBERNETES_TOKEN</li>
<li>Update the value of CRD name</li>
</ul>
<div class="highlight"><pre><span></span><code>    KUBERNETES_CRD=custom-isecl-sgx
</code></pre></div>
<h5 id="deploy-isecl-scheduler">Deploy isecl-scheduler</h5>
<p>The isecl-scheduler default configuration is provided for common cluster support in isecl-scheduler.yaml.</p>
<p>Variables HVS_IHUB_PUBLIC_KEY_PATH and SGX_IHUB_PUBLIC_KEY_PATH are by default set to default paths. </p>
<p>Please use and set only required variables based on the use case.</p>
<p>For example, if only sgx based attestation is required then remove/comment HVS_IHUB_PUBLIC_KEY_PATH variables.</p>
<ul>
<li>
<p>Install cfssl and cfssljson on Kubernetes Control Plane
<div class="highlight"><pre><span></span><code>    #Download cfssl to /usr/local/bin/
    wget -O /usr/local/bin/cfssl http://pkg.cfssl.org/R1.2/cfssl_linux-amd64
    chmod +x /usr/local/bin/cfssl

    #Download cfssljson to /usr/local/bin
    wget -O /usr/local/bin/cfssljson http://pkg.cfssl.org/R1.2/cfssljson_linux-amd64
    chmod +x /usr/local/bin/cfssljson
</code></pre></div></p>
</li>
<li>
<p>Create tls key pair for isecl-scheduler service, which is signed by k8s apiserver.crt</p>
</li>
</ul>
<div class="highlight"><pre><span></span><code>    cd /opt/isecl-k8s-extensions/
    chmod +x create_k8s_extsched_cert.sh
    ./create_k8s_extsched_cert.sh -n &quot;K8S Extended Scheduler&quot; -s &quot;&lt;K8_MASTER_IP&gt;&quot;,&quot;&lt;K8_MASTER_HOST&gt;&quot; -c /etc/kubernetes/pki/ca.crt -k /etc/kubernetes/pki/ca.key
</code></pre></div>
<ul>
<li>After iHub deployment, copy /etc/ihub/ihub_public_key.pem from ihub to /opt/isecl-k8s-extensions/ directory on k8 master vm. Also, copy tls key pair generated in previous step to secrets directory.</li>
</ul>
<div class="highlight"><pre><span></span><code>    mkdir secrets
    cp /opt/isecl-k8s-extensions/server.key secrets/
    cp /opt/isecl-k8s-extensions/server.crt secrets/
    mv /opt/isecl-k8s-extensions/ihub_public_key.pem /opt/isecl-k8s-extensions/sgx_ihub_public_key.pem
    cp /opt/isecl-k8s-extensions/sgx_ihub_public_key.pem secrets/
</code></pre></div>
<p>Note: Prefix the attestation type for ihub_public_key.pem before copying to secrets folder.</p>
<ul>
<li>Create kubernetes secrets scheduler-secret for isecl-scheduler</li>
</ul>
<div class="highlight"><pre><span></span><code>    kubectl create secret generic scheduler-certs --namespace isecl --from-file=secrets
</code></pre></div>
<ul>
<li>Deploy isecl-scheduler</li>
</ul>
<div class="highlight"><pre><span></span><code>    kubectl apply -f yamls/isecl-scheduler.yaml
</code></pre></div>
<ul>
<li>Check whether the isecl-scheduler is up and running</li>
</ul>
<div class="highlight"><pre><span></span><code>    kubectl get deploy -n isecl
</code></pre></div>
<h5 id="configure-kube-scheduler-to-establish-communication-with-isecl-scheduler">Configure kube-scheduler to establish communication with isecl-scheduler</h5>
<ul>
<li>Add scheduler-policy.json under kube-scheduler section, mountPath under container section and hostPath under volumes section in /etc/kubernetes/manifests/kube-scheduler.yaml as mentioned below</li>
</ul>
<div class="highlight"><pre><span></span><code>spec:
  containers:
  - command:
    - kube-scheduler
    - --policy-config-file=/opt/isecl-k8s-extensions/scheduler-policy.json
</code></pre></div>
<div class="highlight"><pre><span></span><code>  containers:
    volumeMounts:
    - mountPath: /opt/isecl-k8s-extensions/
      name: extendedsched
      readOnly: true
</code></pre></div>
<div class="highlight"><pre><span></span><code>  volumes:
  - hostPath:
      path: /opt/isecl-k8s-extensions/
      type:
    name: extendedsched
</code></pre></div>
<p>Note: Make sure to use proper indentation and don't delete existing mountPath and hostPath sections in kube-scheduler.yaml.</p>
<ul>
<li>Restart Kubelet which restart all the k8s services including kube base schedular</li>
</ul>
<div class="highlight"><pre><span></span><code>    systemctl restart kubelet
</code></pre></div>
<ul>
<li>Check if CRD Data is populated</li>
</ul>
<div class="highlight"><pre><span></span><code>    kubectl get -o json hostattributes.crd.isecl.intel.com
</code></pre></div>
<h2 id="installing-the-integration-hub">Installing the Integration Hub</h2>
<p><strong>Note:</strong> The Integration Hub is only required to integrate Intel® SecL with third-party scheduler services, such as Kubernetes. The Integration Hub is not required for usage models that do not require Intel® SecL security attributes to be pushed to an integration endpoint.</p>
<h3 id="required-for_6">Required For</h3>
<p>The Integration Hub is REQUIRED the default orchestrator SGX Agent mode.</p>
<h3 id="prerequisites_4">Prerequisites</h3>
<p>The Intel® Security Libraries Integration Hub can be run on a VM or on a bare-metal server. The Integration Hub may be installed on the same server (physical or VM) as the SGX Host Verification Service.</p>
<ul>
<li>
<p>SGX Caching Service must be installed and available.</p>
</li>
<li>
<p>The SGX Host Verification Service must be installed and available</p>
</li>
<li>
<p>The Authentication and Authorization Service must be installed and available</p>
</li>
<li>
<p>The Certificate Management Service must be installed and available</p>
</li>
</ul>
<h3 id="package-dependencies_5">Package Dependencies</h3>
<p>The Intel® SecL Integration Hub requires a number of packages and their dependencies:</p>
<ul>
<li>Golang packages</li>
</ul>
<p>If these are not already installed, the Integration Hub installer attempts to install these packages automatically using the package manager. Automatic installation requires access to package repositories (the RHEL subscription repositories, the EPEL repository, or a suitable mirror), which may require an Internet connection. If the packages are to be installed from the package repository, be sure to update your repository package lists before installation.</p>
<h3 id="supported-operating-systems_4">Supported Operating Systems</h3>
<p>The Intel Security Libraries Integration Hub supports Red Hat Enterprise Linux 8.2.</p>
<h3 id="recommended-hardware_5">Recommended Hardware</h3>
<ul>
<li>
<p>1 vCPUs</p>
</li>
<li>
<p>RAM: 2 GB</p>
</li>
<li>
<p>1 GB free space to install the Integration Hub (database and log space requirements are dependent on the number of managed servers).</p>
</li>
<li>
<p>One network interface with network access to the SGX Host Verification Service.</p>
</li>
<li>
<p>One network interface with network access to any integration endpoints (for example, OpenStack Nova).</p>
</li>
</ul>
<h4 id="installing-the-integration-hub_1">Installing the Integration Hub</h4>
<p>To install the SGX Integration Hub, follow these steps:</p>
<ol>
<li>
<p>Copy the Integration Hub installation binary to the /root/ directory.</p>
</li>
<li>
<p>Create the ihub.env installation answer file in /root/ directory as below
<div class="highlight"><pre><span></span><code>    IHUB_SERVICE_USERNAME=&lt; IHUB service user username &gt; 
    IHUB_SERVICE_PASSWORD=&lt; IHUB service user password &gt; 
    ATTESTATION_SERVICE_URL=&lt; https://&lt; SHVS IP or Hostname &gt;:13000/sgx-hvs/v1
    ATTESTATION_TYPE=SGX
    CMS_TLS_CERT_SHA384=&lt; CMS TLS digest &gt; 
    BEARER_TOKEN=&lt; Installation token from AAS &gt; 

    AAS_API_URL=https://&lt; AAS IP or Hostname &gt;:8444/aas
    CMS_BASE_URL=https://&lt; CMS IP or Hostname &gt;:8445/cms/v1
    POLL_INTERVAL_MINUTES=2
    TLS_SAN_LIST=&lt; comma separated list of IPs and hostnames for the IHUB &gt;
    TENANT=&lt; tenant-type e.g. KUBERNETES or OPENSTACK &gt;

    # Kubernetes Integration Credentials - required for Kubernetes integration only
    KUBERNETES_URL=&lt; https://&lt; Kubernetes IP &gt;:6443/&gt;
    KUBERNETES_CRD=custom-isecl-sgx
    KUBERNETES_TOKEN=&lt; K8S token &gt;
    KUBERNETES_CERT_FILE =&lt; Path of Kubernetes master node certificate &gt;

    # OpenStack Integration Credentials - required for OpenStack integration only
    OPENSTACK_AUTH_URL=&lt;OpenStack Keystone URL; typically http://openstack-ip:5000/&gt;
    OPENSTACK_PLACEMENT_URL=&lt;OpenStack Nova Placement API URL; typically http://openstack-ip:8778/&gt;
    OPENSTACK_USERNAME=&lt; OpenStack username &gt;
    OPENSTACK_PASSWORD=&lt; OpenStack password &gt;
</code></pre></div></p>
</li>
<li>Create Integrated Hub Service user account and Roles. A sample script is provided in the appendix section for reference</li>
</ol>
<p>Update the BEARER_TOKEN value in the ihub.env file</p>
<ol>
<li>Execute the installer binary.</li>
</ol>
<p>./ihub-v3.3.1.bin</p>
<p>Copy IHUB public key to the master node and restart kubelet.</p>
<div class="highlight"><pre><span></span><code>    scp -r /etc/ihub/ihub_public_key.pem &lt;master-node IP&gt;:/opt/isecl-k8s-extensions/
    systemctl restart kubelet
</code></pre></div>
<p>Run this command to validate if the data has been pushed to CRD: </p>
<div class="highlight"><pre><span></span><code>    kubectl get -o json hostattributes.crd.isecl.intel.com
</code></pre></div>
<p>Run this command to validate that the labels have been populated:</p>
<div class="highlight"><pre><span></span><code>    kubectl get nodes --show-labels.
</code></pre></div>
<p>Sample labels:</p>
<div class="highlight"><pre><span></span><code>    EPC-Memory=2.0GB,FLC-Enabled=true,SGX-Enabled=true,SGX-Supported=true,SgxTrustExpiry=2020-11-09T08.07.43Z,TCBUpToDate=true
</code></pre></div>
<p>Create sample yml file for nginx workload and add SGX labels to it such as:</p>
<div class="highlight"><pre><span></span><code>apiVersion: v1
kind: Pod
metadata:
  name: nginx
  labels:
    name: nginx
spec:
  affinity:
    nodeAffinity:
     requiredDuringSchedulingIgnoredDuringExecution:
       nodeSelectorTerms:
       - matchExpressions:
         - key: SGX-Enabled
           operator: In
           values:
           - &quot;true&quot;
         - key: EPC-Memory
           operator: In
           values:
           - &quot;2.0GB&quot;
  containers:
  - name: nginx
    image: nginx
    ports:
    - containerPort: 80
</code></pre></div>
<p>Validate if pod can be launched on the node. Run following commands:</p>
<div class="highlight"><pre><span></span><code>    kubectl apply -f pod.yml
    kubectl get pods
    kubectl describe pods nginx 
</code></pre></div>
<p>Pod should be in running state and launched on the host as per values in pod.yml. Validate running below commands on sgx host:</p>
<div class="highlight"><pre><span></span><code>    docker ps
</code></pre></div>
<h2 id="integration-with-openstack">Integration with OpenStack</h2>
<p>OpenStack can now use “Traits” to provide qualitative data about Nova Compute hosts to establish Trait requirements. The Integration Hub continually push SGX data to the OpenStack Traits resources. This means OpenStack scheduler natively supports workload scheduling incorporating SGX Host information, including SGX enabled/disabled, SGX supported/not supported, FLC enabled/not enabled, EPC memory size, TCB status upto date/not. The OpenStack Placement Service will automatically attempt to place images with Trait requirements on compute nodes that have those Traits.</p>
<p>NOTE: This control only applies to instances launched using the OpenStack scheduler, and the Traits functions will not affect manually-launched instances where a specific Compute Node is defined (since this does not use the scheduler at all). Intel SecL-DC uses existing OpenStack interfaces and does not modify OpenStack code.  The datacenter owner or OpenStack administrator is responsible for the security of the OpenStack workload scheduling process in general, and Intel recommends following published OpenStack security best practices.</p>
<p>Setting Image Traits
Image Traits define the policy for which Traits are required for that instance to be launched on a Nova Compute node.By setting these Traits to “required” the OpenStack scheduler will require the same Traits to be present on a Nova Compute node in order to launch instances. To set the Image Traits for Intel SecL-DC,a specific naming convention is used. This naming convention will match the Traits that the Integration Hub will automatically push to OpenStack. Two types of Traits are currently supported – one Trait is used to require that the Compute Node must be SGX supported and the other Trait is used to require specific SGXkey/value pairs.
Required Image trait for SGX Enabled Host:
<div class="highlight"><pre><span></span><code>CUSTOM_ISECL_SGX_ENABLED_TRUE=required
</code></pre></div>
These Traits can be set using CLI commands for OpenStack Glance:
<div class="highlight"><pre><span></span><code>openstack image set --property trait:CUSTOM_ISECL_SGX_ENABLED_TRUE=required &lt;image name&gt;
</code></pre></div>
To veiw the Traits that has been set:
<div class="highlight"><pre><span></span><code>openstack image show
</code></pre></div>
List the set of resources mapped to the Openstack
<div class="highlight"><pre><span></span><code>openstack resource provider list
</code></pre></div>
To view the traits enabled for the SGX Host:
<div class="highlight"><pre><span></span><code>openstack resource provider trait list &lt;uuid of the host which the openstack resoruce provider lists&gt;
</code></pre></div>
Create the instances
<div class="highlight"><pre><span></span><code>openstack server create --flavor tiny --image &lt;image name&gt; --net vmnet &lt;vm instance name&gt;
</code></pre></div>
Instances should be created and the status should be "Active". Instance should be launched successfully.
<div class="highlight"><pre><span></span><code>openstack server list
</code></pre></div>
To remove a Trait that is not required for an Image:
<div class="highlight"><pre><span></span><code>openstack image unset --property trait:CUSTOM_ISECL_SGX_ENABLED_TRUE 
openstack image unset --property trait:CUSTOM_ISECL_SGX_ENABLED_FALSE 
</code></pre></div>
Scheduling Instances
Once Trait requirements are set for Images and the Integration Hub is configured to push attributes to OpenStack, instances can be launched in OpenStack as normal. As long as the OpenStack Nova scheduler is used to schedule the workloads, only compliant Compute Nodes will be scheduled to run instances of controlled Images.</p>
<p>NOTE: This control only applies to instances launched using the OpenStack scheduler and the Traits functions will not affect manually-launched instances where a specific Compute Node is defined (since this does not use the scheduler at all). Intel SecL-DC uses existing OpenStack interfaces and does not modify OpenStack code. The datacenter owner or OpenStack administrator is responsible for the security of the
OpenStack workload scheduling process in general and Intel recommends following published OpenStack security best practices.</p>
<h2 id="installing-the-key-broker-service">Installing the Key Broker Service</h2>
<h3 id="required-for_7">Required for</h3>
<p>The KBS is REQUIRED for</p>
<p>- Storing Application Keys and Verifying the SGX Quote</p>
<h3 id="prerequisites_5">Prerequisites</h3>
<p>The following must be completed before installing the Key Broker:</p>
<ul>
<li>
<p>The Authentication and Authorization Service must be installed and available</p>
</li>
<li>
<p>The Certificate Management Service must be installed and available</p>
</li>
</ul>
<h3 id="package-dependencies_6">Package Dependencies</h3>
<p>N/A</p>
<h3 id="supported-operating-systems_5">Supported Operating Systems</h3>
<p>supports Red Hat Enterprise Linux 8.2.</p>
<h3 id="recommended-hardware_6">Recommended Hardware</h3>
<p>NA</p>
<h3 id="installation_6">Installation</h3>
<ol>
<li>
<p>Copy the Key Broker installation binary to the /root/ directory.</p>
</li>
<li>
<p>Create the installation answer file kbs.env /root/ directory as below:</p>
<p>KBS_SERVICE_USERNAME=&lt; KBS service user username &gt; </p>
<p>KBS_SERVICE_PASSWORD=&lt; KBS service user password &gt; </p>
<p>SERVER_PORT=9443</p>
<p>AAS_API_URL=https://<AAS IP or hostname>:8444/aas</p>
<p>CMS_BASE_URL=https://<CMS IP or hostname>:8445/cms/v1/</p>
<p>SQVS_URL=https://<SQVS IP or hostname>:12000/svs/v1</p>
<p>KEY_MANAGER=Directory</p>
<p>ENDPOINT_URL=<a href="https://kbshostname:9443/v1">https://kbshostname:9443/v1</a></p>
<p>TLS_COMMON_NAME="KBS TLS Certificate"</p>
<p>SKC_CHALLENGE_TYPE="SGX"</p>
<p>CMS_TLS_CERT_SHA384=<SHA384 hash of CMS TLS certificate></p>
<p>TLS_SAN_LIST=<KBS Hostname/IP></p>
<p>BEARER_TOKEN=<Installation token from AAS></p>
</li>
</ol>
<p>BEARER_TOKEN above can be obtained form Step 3 below</p>
<ol>
<li>
<p>Create Key Broker Service user account and Roles. A sample script is provided in the appendix section for reference</p>
</li>
<li>
<p>Execute the KBS installer.</p>
</li>
</ol>
<p>./kbs-3.3.0.bin</p>
<h2 id="installing-the-skc-library">Installing the SKC Library</h2>
<h3 id="required-for_8">Required For</h3>
<p>The SKC_Library enables secure transfer of application keys from KBS after performing SGX attestation. It stores the keys in the SGX enclave and performs crypto operations ensuring the keys are never exposed in use, at rest and in transit outside of enclave.</p>
<h3 id="package-dependencies_7">Package Dependencies</h3>
<p>The Intel® Security Libraries SKC Library requires the following packages and their dependencies</p>
<p>Openssl</p>
<p>Curl</p>
<h3 id="supported-operation-system">Supported Operation System</h3>
<p>The Intel® Security Libraries SKC Library supports Red Hat Enterprise Linux 8.2.</p>
<h3 id="recommended-hardware_7">Recommended Hardware</h3>
<ul>
<li>
<p>Icelake Server with SGX enabled in BIOS</p>
</li>
<li>
<p>RAM: 8 GB</p>
</li>
<li>
<p>100 GB</p>
</li>
<li>
<p>One network interface with network access to the Key Broker</p>
</li>
</ul>
<h3 id="installation_7">Installation</h3>
<pre><code>Copy skc_library.tar skc_library.sha2 and skclib_untar.sh to a directory in SGX Compute node
./skclib_untar.sh
Update the IP address for the services mentioned in skc_library.conf (SCS IP Should be set to CSP SCS IP)
./deploy_skc_library.sh
</code></pre>
<h1 id="authentication">Authentication</h1>
<p>Authentication is centrally managed by the Authentication and Authorization Service (AAS). This service uses a Bearer Token authentication method. This service also centralizes the creation of roles and users, allowing much easier management of users, passwords, and permissions across all Intel® SecL-DC services.</p>
<p>To make an API request to an Intel® SecL-DC service, an authentication token is required. API requests must now include an Authorization header with a valid token</p>
<p>The token is issued by AAS and expires after a set amount of time. This token may be used with any Intel® SecL-DC service and will carry the appropriate permissions for the role(s) assigned to the account the token was generated for.</p>
<p>The SKC solution involves AAS deployments for 2 different domains: the CSP domain and the tenant domain. There is no trust relationship between the 2 deployments.</p>
<p>In SKC, the accounts of the SGX Services are created at install time. However, CSP admin users must obtain AAS tokens to invoke admin APIs in the SGX Host Verification Service (SHVS), the SGX Hub, the SGX Caching Service (SCS) and AAS.</p>
<p>Similarly, the tenant admin needs AAS tokens to invoke Create, Read, Update and Delete (CRUD) APIs in KBS and admin APIs in AAS.</p>
<p>The following sections present how to use AAS APIs to create tokens and manage users.</p>
<h2 id="create-token">Create Token</h2>
<p>To request a new token from the AAS:</p>
<p>POST https://\&lt;AAS IP or hostname>:8444/aas/token</p>
<p>{</p>
<p>\"username\" : \"\&lt;username>\",</p>
<p>\"password\" : \"\&lt;password>\"</p>
<p>}</p>
<p>The response will be a token that can be used in the Authorization header for other requests. The length of time for which the token will be valid is configured on the AAS using the key ~AAS_JWT_TOKEN_DURATION_MINS~ (in the installation answer file during installation) or aas.jwt.token.duration.mins (configured on the AAS after installation). In both cases the value is the length of time in minutes that issued tokens will remain valid before expiring.</p>
<h2 id="user-management">User Management</h2>
<p>Users in Intel® SecL-DC are centrally managed by the Authentication and Authorization Service (AAS). Any user may be assigned roles for any service, allowing user accounts to be fully defined by the tasks needed</p>
<h3 id="username-and-password-requirement">Username and Password Requirement</h3>
<p>Passwords have the following constraints:</p>
<ul>
<li>
<p>cannot be empty - ie must at least have one character</p>
</li>
<li>
<p>maximum length of 255 characters</p>
</li>
</ul>
<p>Usernames have the following requirements:</p>
<ul>
<li>
<p>Format: username[\@host_name[domain]]</p>
</li>
<li>
<p>[\@host_name[domain]] is optional</p>
</li>
<li>
<p>username shall be minimum of 2 and maximum of 255 characters</p>
</li>
<li>
<p>username allowed characters are alphanumeric, ., -, _ - but cannot start with -.</p>
</li>
<li>
<p>Domain name must meet requirements of a host name or fully qualified internet host name</p>
</li>
<li>
<p>(Update it relevant to SKC)</p>
</li>
</ul>
<h3 id="create-user">Create User</h3>
<p>POST https://\&lt;IP or hostname of AAS>:8444/aas/users</p>
<p>Authorization: Bearer \&lt;token></p>
<p>{</p>
<p>\"username\" : \"\&lt;username>\",</p>
<p>\"password\" : \"\&lt;password>\"</p>
<p>}</p>
<h3 id="search-user">Search User</h3>
<p>GET https://\&lt;IP or hostname of AAS>:8444/aas/users?\&lt;parameter>=\&lt;value></p>
<p>Authorization: Bearer \&lt;token></p>
<h3 id="change-user-password">Change User Password</h3>
<p>PATCH https://\&lt;IP or hostname of AAS>:8444/aas/users/changepassword</p>
<p>{</p>
<p>\"username\": \"\&lt;username>\",</p>
<p>\"old_password\": \"\&lt;old_password>\",</p>
<p>\"new_password\": \"\&lt;new_password>\",</p>
<p>\"password_confirm\": \"\&lt;new_password>\" }</p>
<h3 id="delete-user">Delete User</h3>
<p>DELETE https://\&lt;IP or hostname of AAS>:8444/aas/users/\&lt;User ID></p>
<p>Authorization: Bearer \&lt;token></p>
<h2 id="roles-and-permission">Roles and Permission</h2>
<p>Permissions in Intel® SecL-DC are managed by Roles. Roles are a set of predefined permissions applicable to a specific service. Any number of Roles may be applied to a User. While new Roles can be created, each Intel® SecL service defines permissions that are applicable to specific predetermined Roles. This means that only pre-defined Roles will actually have any permissions. Role creation is intended to allow Intel® SecL-DC services to define their permissions while allowing role and user management to be centrally managed on the AAS. When a new service is installed, it will use the Role creation functions to define roles applicable for that service in the AAS.</p>
<h3 id="create-roles">Create Roles</h3>
<p>POST https://\&lt;AAS IP or Hostname>:8444/aas/roles</p>
<p>Authorization: Bearer \&lt;token></p>
<p>{</p>
<p>\"service\": \"\&lt;Service name>\",</p>
<p>\"name\": \"\&lt;Role Name>\".</p>
<p>"permissions": [\&lt;array of permissions>]</p>
<p>}</p>
<ul>
<li>
<p>Service field contains a minimum of 1 and maximum of 20 characters. Allowed characters are alphanumeric plus the special charecters -, _, @, ., ,</p>
</li>
<li>
<p>Name field contains a minimum of 1 and maximum of 40 characters. Allowed characters are alphanumeric plus the special characters -, _, @, ., ,</p>
</li>
<li>
<p>Service and Name fields are mandatory</p>
</li>
<li>
<p>Context field is optional and can contain up to 512 characters. Allowed characters are alphanumeric plus -, _, @, ., ,,=,;,:,*</p>
</li>
<li>
<p>Permissions field is optional and allow up to a maximum of 512 characters.</p>
</li>
</ul>
<p>The Permissions array must a comma-separated list of permissions formatted as resource:action:</p>
<p>Permissions required to execute specific API requests are listed with the API resource and method definitions in the API documentation.</p>
<h3 id="search-roles">Search Roles</h3>
<p>GET https://\&lt;AAS IP or Hostname>:8444/aas/roles?\&lt;parameter>=\&lt;value></p>
<p>Authorization: Bearer \&lt;token></p>
<p>Search parameters supported:</p>
<p>Service=\&lt;name of service></p>
<p>Name=\&lt;role name></p>
<p>Context=\&lt;context></p>
<p>contextContains=\&lt;partial "context" string></p>
<p>allContexts=\&lt;true or false> filter=false</p>
<h3 id="delete-role">Delete Role</h3>
<p>DELETE https://\&lt;AAS IP or Hostname>:8444/aas/roles/\&lt;role ID> Authorization:</p>
<p>Bearer \&lt;token></p>
<h3 id="assign-role-to-user">Assign Role to User</h3>
<p>POST https://\&lt;AAS IP or Hostname>:8444/aas/users/\&lt;user ID>/roles</p>
<p>Authorization: Bearer \&lt;token></p>
<p>{</p>
<p>\"role_ids\": [\"\&lt;comma-separated list of role IDs>\"]</p>
<p>}</p>
<h3 id="list-roles-assigned-to-user">List Roles Assigned to User</h3>
<p>GET https://\&lt;AAS IP or Hostname>:8444/aas/users/\&lt;user ID>/roles</p>
<p>Authorization: Bearer \&lt;token></p>
<h3 id="remove-role-from-user">Remove Role from User</h3>
<p>DELETE https://\&lt;AAS IP or Hostname>:8444/aas/users/\&lt;user ID>/roles/\&lt;role ID></p>
<p>Authorization: Bearer \&lt;token></p>
<h3 id="role-definitions">Role Definitions</h3>
<p>Following are the set of roles which are required during installation and runtime.</p>
<table>
<thead>
<tr>
<th>Role Name</th>
<th>Permissions</th>
<th>Utility</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt; SGX_AGENT:HostDataReader: &gt;</td>
<td></td>
<td>Used by the SHVS to retrieve platform data from SGX_Agent</td>
</tr>
<tr>
<td>&lt; CMS:CertApprover:CN=SGX_AGENT TLS Certificate;SAN=<san list>;CERTTYPE=TLS&gt;</td>
<td></td>
<td>Used by the SGX-AGENT to get TLS certificate from CMS</td>
</tr>
<tr>
<td>&lt; SHVS:HostRegistration: &gt;</td>
<td></td>
<td>Used by the SGX_Agent to register host to the SHVS</td>
</tr>
<tr>
<td>&lt; SHVS:HostsListReader: &gt;</td>
<td></td>
<td>Used by the IHUB to retrieve the list of hosts from SHVS</td>
</tr>
<tr>
<td>&lt; SHVS:HostDataReader: &gt;</td>
<td></td>
<td>Used by the IHUB to retrieve platform-data from SHVS</td>
</tr>
<tr>
<td>&lt; CMS:CertApprover:CN=SHVS TLS Certificate;SAN=<san list>;CERTTYPE=TLS&gt;</td>
<td></td>
<td>Used by the SHVS to retrieve TLS Certificate from CMS</td>
</tr>
<tr>
<td>&lt; CMS:CertApprover:CN=Integration HUB TLS Certificate;SAN=<san list>;CERTTYPE=TLS&gt;</td>
<td></td>
<td>Used by the IHUB to retrieve TLS Certificate from CMS</td>
</tr>
<tr>
<td>&lt; SCS:HostDataUpdater: &gt;</td>
<td></td>
<td>Used by the SHVS to push the platform-info to SCS</td>
</tr>
<tr>
<td>&lt; SCS:HostDataReader: &gt;</td>
<td></td>
<td>Used by the SHVS to retrieve the TCB status info from SCS</td>
</tr>
<tr>
<td>&lt; SCS:CacheManager: &gt;</td>
<td></td>
<td>Used by the SCS admin to refresh the platform info</td>
</tr>
<tr>
<td>&lt; CMS:CertApprover:CN=SCS TLS Certificate;SAN=<san list>;CERTTYPE=TLS&gt;</td>
<td></td>
<td>Used by the SCS to retrieve TLS Certificate from CMS</td>
</tr>
<tr>
<td>&lt; KBS:KeyTransfer:permissions=nginx,USA &gt;</td>
<td></td>
<td>Used by the SKC Library user for Key Transfer</td>
</tr>
<tr>
<td>&lt; CMS:CertApprover:CN=skcuser;CERTTYPE=TLS-Client&gt;</td>
<td></td>
<td>Used by the SKC Library user to retrieve TLS-Client Certificate from CMS</td>
</tr>
<tr>
<td>&lt; CMS:CertApprover:CN=KBS TLS Certificate;SAN=<san list>;CERTTYPE=TLS&gt;</td>
<td></td>
<td>Used by the KBS to retrieve TLS Certificate from CMS</td>
</tr>
<tr>
<td>AAS: Administrator</td>
<td><em>:</em>:*</td>
<td>Administrator role for the AAS only. Has all permissions for AAS resources, including the ability to create or delete users and roles</td>
</tr>
<tr>
<td>AAS: RoleManager</td>
<td>AAS: [roles:create:<em>, roles:retrieve:</em>, roles:search:<em>, roles:delete:</em>]</td>
<td>AAS role that allows all actions for Roles but cannot create or delete Users or assign Roles to Users.</td>
</tr>
<tr>
<td>AAS: UserManager</td>
<td>AAS: [users:create:<em>, users:retrieve:</em>, users:store:<em>, users:search:</em>, users:delete:*]</td>
<td>AAS role with all permissions for Users but has no ability to create Roles or assign Roles to Users.</td>
</tr>
<tr>
<td>AAS: UserRoleManager</td>
<td>AAS: [user_roles:create:<em>, user_roles:retrieve:</em>, user_roles:search:<em>, user_roles:delete:</em>]</td>
<td>AAS role with permissions to assign Roles to Users but cannot create delete or modify Users or Roles.</td>
</tr>
<tr>
<td>&lt; SHVS:HostListManager:&gt;</td>
<td></td>
<td>Used by the SHVS admin to delete the hosts.</td>
</tr>
<tr>
<td>&lt; SQVS:QuoteVerifier: &gt;</td>
<td></td>
<td>Used by the KBS service user for quote verification</td>
</tr>
</tbody>
</table>
<h1 id="connection-strings">Connection Strings</h1>
<p>Connection Strings define a remote API resource endpoint that will be used to communicate with the registered host for retrieving SGX information and another platform information. Connection Strings differ based on the type of host.</p>
<h2 id="sgx-agent_1">SGX Agent</h2>
<p>The SGX Agent connection string connects directly to the SGX Agent on a given host. The SGX Host Verification Service will use a service account with the needed SGX Agent permissions to connect to the SGX Agent. Authentication has been centralized with the new Authentication and Authorization Service.</p>
<h1 id="sgx-features-provisioning">SGX Features Provisioning</h1>
<h2 id="host-registration">Host Registration</h2>
<p>Host Registration creates a host record with connectivity details and other host information in the SGX host Verification Service database. This host record will be used by the SGX Host Verification Service to retrieve SGX information and platform values from the SGX Agent.</p>
<h3 id="sgx-agent_2">SGX Agent</h3>
<h4 id="host-registration-with-sgx-agent">Host Registration with SGX Agent</h4>
<p>The SGX Agent registers the host with an SGX Host Verification Service at the time of installation.</p>
<h3 id="retrieving-current-host-state-information">Retrieving Current Host State Information</h3>
<p>Admin can get the host state information by calling this rest API. GET https://\&lt;hostname>:13000/sgx-hvs/v1/host-status</p>
<h1 id="intel-security-libraries-configuration-settings">Intel Security Libraries Configuration Settings</h1>
<h2 id="sgx-host-verification-service_1">SGX Host Verification Service</h2>
<h3 id="installation-answer-file-options">Installation Answer File Options</h3>
<table>
<thead>
<tr>
<th>Key</th>
<th>Sample Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>CMS_BASE_URL</td>
<td>https://&lt; IP address or hostname for CMS &gt;:8445/cms/v1/</td>
<td>Base URL of the CMS</td>
</tr>
<tr>
<td>AAS_API_URL</td>
<td>https://&lt; IP address or hostname for AAS &gt;:8444/aas</td>
<td>Base URL of the AAS</td>
</tr>
<tr>
<td>SCS_BASE_URL</td>
<td>https://&lt; IP or hostname of SCS &gt;:9000/scs/sgx/</td>
<td>Base URL of SCS</td>
</tr>
<tr>
<td>SHVS_DB_PORT</td>
<td>5432</td>
<td>Defines the port number for communication with the database server. By default, with a local database server installation, this port will be set to 5432.</td>
</tr>
<tr>
<td>SHVS_DB_NAME</td>
<td>pgshvsdb</td>
<td>Defines the schema name of the database. If a remote database connection will be used, this schema must be created in the remote database before installing the SGX Host Verification Service</td>
</tr>
<tr>
<td>SHVS_DB_USERNAME</td>
<td>aasdbuser</td>
<td>Username for accessing the database. If a remote database connection will be used, this user/password must be created and granted all permissions for the database schema before installing the SGX Host Verification Service.</td>
</tr>
<tr>
<td>SHVS_DB_PASSWORD</td>
<td>aasdbpassword</td>
<td>Password for accessing the database. If a remote database connection will be used, this user/password must be created and granted all permissions for the database schema before installing the SGX Host Verification Service.</td>
</tr>
<tr>
<td>SHVS_DB_HOSTNAME</td>
<td>localhost</td>
<td>Defines the database server IP address or hostname. This should be the loopback address for local database server installations but should be the IP address or hostname of the database server if a remote database will be used.</td>
</tr>
<tr>
<td>SAN_LIST</td>
<td>127.0.0.1,localhost</td>
<td>Comma-separated list of IP addresses and hostnames that will be valid connection points for the service. Requests sent to the service using an IP or hostname not in this list will be denied, even if it resolves to this service</td>
</tr>
<tr>
<td>SHVS_ADMIN_USERNAME</td>
<td>shvsuser@shvs</td>
<td>Username for a new user to be created during installation.</td>
</tr>
<tr>
<td>SHVS_ADMIN_PASSWORD</td>
<td>shvspassword</td>
<td>Password for the user to be created during installation.</td>
</tr>
<tr>
<td>CMS_TLS_CERT_SHA384</td>
<td>&lt; Certificate Management Service TLS digest&gt;</td>
<td>SHA384 hash of the CMS TLS certificate</td>
</tr>
<tr>
<td>BEARER_TOKEN</td>
<td></td>
<td>Installation token from AAS</td>
</tr>
<tr>
<td>SHVS_PORT</td>
<td>13000</td>
<td>SGX Host Verification Service HTTP Port</td>
</tr>
<tr>
<td>SHVS_SCHEDULER_TIMER</td>
<td>60</td>
<td>SHVS Scheduler timeout</td>
</tr>
<tr>
<td>SHVS_HOST_PLATFORM_EXPIRY_TIME</td>
<td>4</td>
<td>SHVS Host Info Expiry time</td>
</tr>
<tr>
<td>SHVS_AUTO_REFRESH_TIMER</td>
<td>120</td>
<td>SHVS Auto-refresh timeout</td>
</tr>
</tbody>
</table>
<h3 id="configuration-options">Configuration Options</h3>
<p>The SGX Host Verification Service configuration in path /etc/shvs/config.yml.</p>
<h3 id="command-line-options">Command-Line Options</h3>
<p>The SGX Host Verification Service supports several command-line commands that can be executed only as the Root user:</p>
<p>Syntax:</p>
<p>shvs \&lt;command></p>
<h4 id="help">Help</h4>
<p>shvs help</p>
<p>Displays the list of available CLI commands.</p>
<h4 id="start">Start</h4>
<p>shvs start</p>
<p>Starts the SGX Host Verification service</p>
<h4 id="stop">Stop</h4>
<p>shvs stop</p>
<p>Stops the SGX Host Verification service</p>
<h4 id="status">Status</h4>
<p>shvs status</p>
<p>Reports whether the service is currently running.</p>
<h4 id="uninstall">Uninstall</h4>
<p>shvs uninstall [--purge]</p>
<p>Removes the service. Use --purge option to remove configuration directory(/etc/shvs/)</p>
<h4 id="version">Version</h4>
<p>shvs version</p>
<p>Shows the version of the service.</p>
<h3 id="directory-layout">Directory Layout</h3>
<p>The SGX Host Verification Service installs by default to /opt/shvs with the following folders.</p>
<h4 id="bin">Bin</h4>
<p>This folder contains executable scripts.</p>
<p><strong>9.1.4.2 Dbscripts</strong></p>
<p>Contains database scripts.</p>
<p><strong>Other folders which are created during installation are:</strong></p>
<h4 id="configuration">Configuration</h4>
<p>This folder /etc/shvs contains certificates, keys, and configuration files.</p>
<h4 id="logs">Logs</h4>
<p>This folder contains log files: /var/log/shvs/</p>
<h2 id="sgx-agent_3">SGX Agent</h2>
<h3 id="installation-answer-file-options_1">Installation Answer File Options</h3>
<table>
<thead>
<tr>
<th>Key</th>
<th>Sample Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>AAS_API_URL</td>
<td>https://&lt; AAS IP or Hostname&gt;:8444/aas</td>
<td>API URL for Authentication Authorization Service (AAS).</td>
</tr>
<tr>
<td>CMS_BASE_URL</td>
<td>https://&lt; CMS IP or hostname&gt;:8445/cms/v1/</td>
<td>API URL for Certificate Management Service (CMS).</td>
</tr>
<tr>
<td>SHVS_BASE_URL</td>
<td>https://&lt; SHVS IP or hostname&gt;:13000/sgx-hvs/v1/</td>
<td>The url used during setup to request information from SHVS.</td>
</tr>
<tr>
<td>SGX_AGENT_USERNAME</td>
<td>sgx_agent</td>
<td>Name of the SGX_AGENT USER</td>
</tr>
<tr>
<td>SGX_AGENT_PASSWORD</td>
<td>password</td>
<td>Password of SGX_AGENT user.</td>
</tr>
<tr>
<td>BEARER_TOKEN</td>
<td></td>
<td>JWT from AAS that contains "install" permissions needed to access ISecL services during provisioning and registration</td>
</tr>
<tr>
<td>CMS_TLS_CERT_SHA384</td>
<td>&lt; Certificate Management Service TLS digest&gt;</td>
<td>SHA384 Hash for verifying the CMS TLS certificate.</td>
</tr>
<tr>
<td>SGX_PORT</td>
<td>11001</td>
<td>The port on which the SGX Agent service will listen.</td>
</tr>
<tr>
<td>SGX_AGENT_MODE</td>
<td>Orchestration</td>
<td>SGX Agent will operate to work in conjuction with orchstrators like Kubernetes</td>
</tr>
<tr>
<td>SGX_AGENT_NOSETUP</td>
<td>false</td>
<td>Skips setup during installation if set to true</td>
</tr>
<tr>
<td>SAN_LIST</td>
<td>127.0.0.1, localhost</td>
<td>Comma-separated list of IP addresses and hostnames that will be valid connection points for the service. Requests sent to the service using an IP or hostname not in this list will be denied, even if it resolves to this service</td>
</tr>
</tbody>
</table>
<h3 id="configuration-options-this-is-same-as-above">Configuration Options - This is same as above.</h3>
<h3 id="command-line-options_1">Command-Line Options</h3>
<p>sgx_agent \&lt;command></p>
<h4 id="available-commands">Available Commands</h4>
<h5 id="help_1">help</h5>
<p>Show the help message.</p>
<h5 id="version_1">Version</h5>
<p>sgx_agent version</p>
<p>Reports the version of the service.</p>
<h5 id="uninstall_1">uninstall</h5>
<p>sgx_agent uninstall --purge</p>
<h5 id="start_1">start</h5>
<p>Start the SGX Agent service. </p>
<p>sgx_agent start</p>
<h5 id="stop_1">stop</h5>
<p>Stop the SGX Agent service. </p>
<p>sgx_agent stop</p>
<h5 id="status_1">status</h5>
<p>Get the status of the SGX Agent Service. </p>
<p>sgx_agent status</p>
<h3 id="directory-layout_1">Directory Layout</h3>
<h4 id="linux">Linux</h4>
<p>The Linux SGX Agent installs by default to /opt/sgx_agent, with the following subfolders:</p>
<h5 id="bin_1">Bin</h5>
<p>Contains executables and scripts.</p>
<h5 id="configuration_1">Configuration</h5>
<p>Contains the config.yml configuration file.</p>
<h2 id="integration-hub_1">Integration Hub</h2>
<h3 id="installation-answer-file">Installation Answer File</h3>
<table>
<thead>
<tr>
<th>Key</th>
<th>sample Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>AAS_API_URL</td>
<td>https://&lt; Authentication and Authorization Service IP or  Hostname&gt;:8444/aas</td>
<td>Base URL for the AAS</td>
</tr>
<tr>
<td>CMS_BASE_URL</td>
<td>https://&lt; Certificate Management Service IP or Hostname&gt;:8445/cms/v1</td>
<td>Base URL for the CMS</td>
</tr>
<tr>
<td>ATTESTATION_SERVICE_URL</td>
<td>https://&lt; SGX Host Verification Service IP or hostname&gt;:13000/sgx-hvs/v1/</td>
<td>Base URL  of SHVS</td>
</tr>
<tr>
<td>ATTESTATION_TYPE</td>
<td>SGX</td>
<td>For SKC, Attestation Type is always SGX</td>
</tr>
<tr>
<td>IHUB_SERVICE_USERNAME</td>
<td>ihubuser@ihub</td>
<td>Database username</td>
</tr>
<tr>
<td>IHUB_SERVICE_PASSWORD</td>
<td>ihubpassword</td>
<td>Database password</td>
</tr>
<tr>
<td>CMS_TLS_CERT_SHA384</td>
<td>&lt; Certificate Management Service TLS digest&gt;</td>
<td>SHA384 digest of the CMS TLS certificate</td>
</tr>
<tr>
<td>BEARER_TOKEN</td>
<td></td>
<td>Installation token</td>
</tr>
<tr>
<td>TENANT</td>
<td>KUBERNETES</td>
<td>Tenant Orchaestrator</td>
</tr>
<tr>
<td>KUBERNETES_URL</td>
<td>https://&lt; Kubernetes Master Node IP or  Hostname&gt; :6443</td>
<td>Kubernetes Master node URL</td>
</tr>
<tr>
<td>KUBERNETES_CRD</td>
<td>custom-isecl-sgx</td>
<td>CRD Name to be used</td>
</tr>
<tr>
<td>TLS_SAN_LIST</td>
<td>127.0.0.1, localhost</td>
<td>Comma-separated list of IP addresses and hostnames that will be valid connection points for the service. Requests sent to the service using an IP or hostname not in this list will be denied, even if it resolves to this service.</td>
</tr>
<tr>
<td>KUBERNETES_TOKEN</td>
<td></td>
<td>Token from Kubernetes Master Node</td>
</tr>
<tr>
<td>KUBERNETES_CERT_FILE</td>
<td>/root/apiserver.crt</td>
<td>Kubernetes server certificate path</td>
</tr>
<tr>
<td>POLL_INTERVAL_MINUTES</td>
<td>2</td>
<td>IHUB Polling Interval in Minutes</td>
</tr>
</tbody>
</table>
<h3 id="configuration-options_1">Configuration Options</h3>
<p>The Integration Hub configuration can be found in /etc/ihub/config.yml.</p>
<h3 id="command-line-options_2">Command-Line Options</h3>
<p>The Integrtion HUB supports several command-line commands that can be executed only as the Root user:</p>
<p>Syntax:</p>
<p>ihub \&lt;command></p>
<h4 id="available-commands_1">Available Commands</h4>
<h5 id="help_2">Help</h5>
<p>ihub help</p>
<p>Displays the list of available CLI commands</p>
<h5 id="start_2">Start</h5>
<p>ihub start</p>
<p>Start the service</p>
<h5 id="stop_2">Stop</h5>
<p>ihub stop</p>
<p>stops the service</p>
<h5 id="status_2">Status</h5>
<p>ihub status</p>
<p>Reports whether the service is currently running.</p>
<h5 id="uninstall_2">Uninstall</h5>
<p>ihub uninstall [--purge]</p>
<p>Removes the service. Use --purge option to remove configuration directory(/etc/ihub/)</p>
<h5 id="version_2">Version</h5>
<p>ihub version</p>
<p>Reports the version of the service.</p>
<h3 id="directory-layout_2">Directory Layout</h3>
<h4 id="logs_1">Logs</h4>
<p>The Integration HUB installs by default to /opt/ihub with the following folders.</p>
<h4 id="bin_2">Bin</h4>
<p>This folder contains executable scripts.</p>
<p><strong>Other folders which are created during installation are:</strong></p>
<h4 id="configuration_2">Configuration</h4>
<p>This folder /etc/ihub/ contains certificates, keys, and configuration files.</p>
<h4 id="logs_2">Logs</h4>
<p>This folder contains log files: /var/log/ihub/</p>
<h2 id="certificate-management-service_1">Certificate Management Service</h2>
<h3 id="installation-answer-file-options_2">Installation Answer File Options</h3>
<table>
<thead>
<tr>
<th>Key</th>
<th>Sample Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>CMS_PORT</td>
<td>8445</td>
<td>Default Port where Certificate Management Service Runs</td>
</tr>
<tr>
<td>CMS_NOSETUP</td>
<td>false</td>
<td>Determines whether “setup” will be executed after installation. Typically this is set to “false” to install and perform setup in one action. The “true” option is intended for building the service as a container, where the installation would be part of the image build, and setup would be performed when the container starts for the first time to generate any persistent data.</td>
</tr>
<tr>
<td>AAS_API_URL</td>
<td>https://&lt; AAS Hostname or IP address&gt;:8444/aas/</td>
<td>URL to connect to the AAS, used during setup for authentication.</td>
</tr>
<tr>
<td>AAS_TLS_SAN</td>
<td>&lt; Comma-separated list of IPs/hostnames for the AAS&gt;</td>
<td>SAN list populated in special JWT token; this token is used by AAS to get TLS certificate signed from CMS. SAN list in this token and CSR generated by AAS must match.</td>
</tr>
</tbody>
</table>
<h3 id="configuration-options_2">Configuration Options</h3>
<p>The CMS configuration can be found in /etc/cms/config.yml.</p>
<h3 id="command-line-options_3">Command-Line Options</h3>
<h4 id="help_3">Help</h4>
<p>cms help</p>
<p>Displays the list of available CLI commands.</p>
<h4 id="start_3">Start</h4>
<p>cms start</p>
<p>Starts the services.</p>
<h4 id="stop_3">Stop</h4>
<p>cms stop</p>
<p>Stops the service.</p>
<h4 id="status_3">Status</h4>
<p>cms status</p>
<p>Reports whether the service is currently running.</p>
<h4 id="uninstall_3">Uninstall</h4>
<p>cms uninstall [--purge]</p>
<p>Uninstalls the service, including the deletion of all files and folders.</p>
<h4 id="version_3">Version</h4>
<p>cms version</p>
<p>Reports the version of the service.</p>
<h4 id="tlscertsha384">Tlscertsha384</h4>
<p>cms tlscertsha384</p>
<p>Shows the SHA384 digest of the TLS certificate.</p>
<h4 id="setup-task">setup [task]</h4>
<p>Runs a specific setup task.</p>
<p>Available Tasks for setup:</p>
<h5 id="cms-setup-server-portport">cms setup server [--port=\&lt;port>]</h5>
<ul>
<li>
<p>Setup http server on \&lt;port></p>
</li>
<li>
<p>Environment variable CMS_PORT=\&lt;port> can be set alternatively</p>
</li>
</ul>
<h5 id="cms-setup-root_ca-force">cms setup root_ca [--force]</h5>
<ul>
<li>
<p>Create its own self signed Root CA keypair in /etc/cms for quality of life</p>
</li>
<li>
<p>Option [--force] overwrites any existing files, and always generate new Root CA keypair</p>
</li>
</ul>
<h5 id="cms-setup-tls-force-host_nameshost_names">cms setup tls [--force] [--host_names=\&lt;host_names>]</h5>
<ul>
<li>
<p>Create its own root_ca signed TLS keypair in /etc/cms for quality of life</p>
</li>
<li>
<p>Option [--force] overwrites any existing files, and always generate root_ca signed TLS keypair</p>
</li>
<li>
<p>Argument \&lt;host_names> is a list of host names used by local machine, seperated by comma</p>
</li>
<li>
<p>Environment variable CMS_HOST_NAMES=\&lt;host_names> can be set alternatively</p>
</li>
</ul>
<h5 id="cms-setup-cms_auth_token-force">cms setup cms_auth_token [--force]</h5>
<ul>
<li>
<p>Create its own self signed JWT keypair in /etc/cms/jwt for quality of life</p>
</li>
<li>
<p>Option [--force] overwrites any existing files, and always generate new</p>
</li>
</ul>
<p>JWT keypair and token</p>
<h3 id="directory-layout_3">Directory Layout</h3>
<p>The Certificate Management Service installs by default to /opt/cms with the following folders.</p>
<h4 id="bin_3">Bin</h4>
<p>This folder contains executable scripts.</p>
<h4 id="cacerts">Cacerts</h4>
<p>This folder contains the CMS root CA certificate.</p>
<h2 id="authentication-and-authorization-service_1">Authentication and Authorization Service</h2>
<h3 id="installation-answer-file-options_3">Installation Answer File Options</h3>
<table>
<thead>
<tr>
<th>Key</th>
<th>Sample Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>CMS_BASE_URL</td>
<td>https://&lt; cms IP or hostname&gt;/cms/v1/</td>
<td>Provides the URL for the CMS.</td>
</tr>
<tr>
<td>AAS_NOSETUP</td>
<td>false</td>
<td>Determines whether “setup” will be executed after installation. Typically this is set to “false” to install and perform setup in one action. The “true” option is intended for building the service as a container, where the installation would be part of the image build, and setup would be performed when the container starts for the first time to generate any persistent data.</td>
</tr>
<tr>
<td>AAS_DB_HOSTNAME</td>
<td>localhost</td>
<td>Hostname or IP address of the AAS database</td>
</tr>
<tr>
<td>AAS_DB_PORT</td>
<td>5432</td>
<td>Database port number</td>
</tr>
<tr>
<td>AAS_DB_NAME</td>
<td>pgdb</td>
<td>Database name</td>
</tr>
<tr>
<td>AAS_DB_USERNAME</td>
<td>aasdbuser</td>
<td>Database username</td>
</tr>
<tr>
<td>AAS_DB_PASSWORD</td>
<td>aasdbpassd</td>
<td>Database password</td>
</tr>
<tr>
<td>AAS_DB_SSLMODE</td>
<td>verify-full</td>
<td></td>
</tr>
<tr>
<td>AAS_DB_SSLCERTSRC</td>
<td>/usr/local/pgsql/data/server.crt</td>
<td>Required if the “AAS_DB_SSLMODE” is set to “verify-ca.” Defines the location of the database SSL certificate.</td>
</tr>
<tr>
<td>AAS_DB_SSLCERT</td>
<td>&lt; path_to_cert_file_on_system &gt;</td>
<td>The AAS_DB_SSLCERTSRC variable defines the  source location of the database SSL certificate; this variable determines the  local location. If the former option  is used without specifying this option, the service will copy the SSL  certificate to the default configuration directory.</td>
</tr>
<tr>
<td>AAS_ADMIN_USERNAME</td>
<td>admin@aas</td>
<td>Defines a new AAS administrative user. This user will be able to create new users, new roles, and new role-user mappings. This user will have the AAS:Administrator role.</td>
</tr>
<tr>
<td>AAS_ADMIN_PASSWORD</td>
<td>aasAdminPass</td>
<td>Password for the new AAS admin user</td>
</tr>
<tr>
<td>AAS_JWT_CERT_SUBJECT</td>
<td>"AAS JWT Signing Certificate"</td>
<td>Defines the subject of the JWT signing certificate.</td>
</tr>
<tr>
<td>AAS_JWT_TOKEN_DURATION</td>
<td>5</td>
<td>Defines the amount of time in minutes that an issued token will be valid.</td>
</tr>
<tr>
<td>SAN_LIST</td>
<td>127.0.0.1,localhost</td>
<td>Comma-separated list of IP addresses and hostnames that will be valid connection points for the service. Requests sent to the service using an IP or hostname not in this list will be denied, even if it resolves to this service.</td>
</tr>
<tr>
<td>BEARER_TOKEN</td>
<td></td>
<td>Installation Token from AAS.</td>
</tr>
</tbody>
</table>
<h3 id="configuration-options_3">Configuration Options</h3>
<p>The AAS configuration can be found in /etc/authservice/config.yml.</p>
<h4 id="help_4">Help</h4>
<p>Displays the list of available CLI commands.</p>
<h4 id="setup-task_1">setup \&lt;task></h4>
<p>Executes a specific setup task. Can be used to change the current configuration.</p>
<p>Available Tasks for setup:</p>
<h5 id="authservice-setup-all">authservice setup all</h5>
<p>Runs all setup tasks</p>
<h5 id="authservice-setup-database-force-argumentsargument_value">authservice setup database [-force] [-arguments=\&lt;argument_value>]</h5>
<ul>
<li>
<p>Available arguments are:</p>
</li>
<li>
<p>db-host alternatively, set environment variable AAS_DB_HOSTNAME</p>
</li>
<li>
<p>db-port alternatively, set environment variable AAS_DB_PORT</p>
</li>
<li>
<p>db-user alternatively, set environment variable AAS_DB_USERNAME</p>
</li>
<li>
<p>db-pass alternatively, set environment variable AAS_DB_PASSWORD</p>
</li>
<li>
<p>db-name alternatively, set environment variable AAS_DB_NAME</p>
</li>
<li>
<p>db-sslmode \&lt;disable|allow|prefer|require|verify-ca|verify-full> alternatively, set environment variable AAS_DB_SSLMODE</p>
</li>
<li>
<p>db-sslcert path to where the certificate file of database. Only applicable for db-sslmode=\&lt;verify-ca|verify-full. If left empty, the cert will be copied to /etc/authservice/tdcertdb.pem alternatively, set environment variable AAS_DB_SSLCERT</p>
</li>
<li>
<p>db-sslcertsrc \&lt;path to where the database ssl/tls certificate file></p>
</li>
</ul>
<p>mandatory if db-sslcert does not already exist alternatively, set environment variable AAS_DB_SSLCERTSRC</p>
<ul>
<li>Run this command with environment variable AAS_DB_REPORT_MAX_ROWS and AAS_DB_REPORT_NUM_ROTATIONS can update db rotation arguments</li>
</ul>
<h5 id="authservice-setup-server-portport">authservice setup server [--port=\&lt;port>]</h5>
<ul>
<li>
<p>Setup http server on \&lt;port></p>
</li>
<li>
<p>Environment variable AAS_PORT=\&lt;port> can be set alternatively authservice setup tls [--force] [--host_names=\&lt;host_names>]</p>
</li>
<li>
<p>Use the key and certificate provided in /etc/threat-detection if files exist</p>
</li>
<li>
<p>Otherwise create its own self-signed TLS keypair in /etc/authservice for quality of life</p>
</li>
<li>
<p>Option [--force] overwrites any existing files, and always generate self-signed keypair</p>
</li>
<li>
<p>Argument \&lt;host_names> is a list of host names used by local machine, seperated by comma</p>
</li>
<li>
<p>Environment variable AAS_TLS_HOST_NAMES=\&lt;host_names> can be set alternatively</p>
</li>
</ul>
<h5 id="authservice-setup-admin-userusername-passpassword">authservice setup admin [--user=\&lt;username>] [-pass=\&lt;password>]</h5>
<ul>
<li>
<p>Environment variable AAS_ADMIN_USERNAME=\&lt;username> can be set alternatively</p>
</li>
<li>
<p>Environment variable AAS_ADMIN_PASSWORD=\&lt;password> can be set alternatively</p>
</li>
</ul>
<h5 id="authservice-setup-jwt">authservice setup jwt</h5>
<ul>
<li>
<p>Create jwt signing key and jwt certificate signed by CMS</p>
</li>
<li>
<p>Environment variable CMS_BASE_URL=\&lt;url> for CMS API url</p>
</li>
<li>
<p>Environment variable AAS_JWT_CERT_CN=\&lt;CERTIFICATE SUBJECT> AAS JWT</p>
</li>
</ul>
<p>Certificate Subject</p>
<ul>
<li>
<p>Environment variable AAS_JWT_INCLUDE_KEYID=\&lt;KEY ID> AAS include key id in JWT Token</p>
</li>
<li>
<p>Environment variable AAS_JWT_TOKEN_DURATION_MINS=\&lt;DURATION> JWT Token validation minutes</p>
</li>
<li>
<p>Environment variable BEARER_TOKEN=\&lt;token> for authenticating with CMS</p>
</li>
</ul>
<h4 id="start_4">Start</h4>
<p>authservice start</p>
<p>Starts the service.</p>
<h4 id="status_4">Status</h4>
<p>authservice status</p>
<p>Displays the current status of the service.</p>
<h4 id="stop_4">Stop</h4>
<p>authservice stop</p>
<p>Stops the service.</p>
<h4 id="uninstall_4">Uninstall</h4>
<p>authservice uninstall [--purge]</p>
<p>Removes the service. Use the "--purge" flag to also delete all data.</p>
<h4 id="version_4">Version</h4>
<p>authservice version</p>
<p>Shows the version of the service.</p>
<h3 id="directory-layout_4">Directory Layout</h3>
<p>The Authendication and Authorization Service installs by default to /opt/authservice with the following folders.</p>
<h4 id="bin_4">Bin</h4>
<p>Contains executable scripts and binaries.</p>
<h4 id="dbscripts">Dbscripts</h4>
<p>Contains database scripts.</p>
<h2 id="key-broker-service">Key Broker Service</h2>
<h3 id="installation-answer-file-options_4">Installation Answer File Options</h3>
<table>
<thead>
<tr>
<th>Variable Name</th>
<th>Default Value</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>CMS_BASE_URL</td>
<td>https://&lt; CMS IP or hostname &gt;:8445/cms/v1/</td>
<td>Required for generating TLS certificate</td>
</tr>
<tr>
<td>AAS_API_URL</td>
<td>https://&lt; AAS IP or hostname &gt;:8444/aas</td>
<td>AAS service url</td>
</tr>
<tr>
<td>SQVS_URL</td>
<td>https://&lt; SQVS IP or hostname &gt;:12000/svs/v1/</td>
<td>Required to get the SGX Quote verified</td>
</tr>
<tr>
<td>CMS_TLS_CERT_SHA384</td>
<td>&lt; Certificate Management Service TLS digest &gt;</td>
<td>SHA384 digest of CMS TLS certificate</td>
</tr>
<tr>
<td>BEARER_TOKEN</td>
<td></td>
<td>JWT token for installation user</td>
</tr>
<tr>
<td>KBS_SERVICE_USERNAME</td>
<td>admin@kms</td>
<td>KBS Service Username</td>
</tr>
<tr>
<td>KBS_SERVICE_PASSWORD</td>
<td>kmsAdminPass</td>
<td>KBS Service User Password</td>
</tr>
<tr>
<td>ENDPOINT_URL</td>
<td><a href="https://kbshostname:9443/v1">https://kbshostname:9443/v1</a></td>
<td>KBS Endpoint URL</td>
</tr>
<tr>
<td>TLS_COMMON_NAME</td>
<td>KBS TLS Certificate</td>
<td>KBS TLS Certificate common-name</td>
</tr>
<tr>
<td>SERVER_PORT</td>
<td>9443</td>
<td>KBS Secure Port</td>
</tr>
<tr>
<td>SKC_CHALLENGE_TYPE</td>
<td>SGX</td>
<td>Challenge Type</td>
</tr>
<tr>
<td>TLS_SAN_LIST</td>
<td>&lt; KBS IP/Hostname &gt;</td>
<td>IP addresses/hostnames to be included in SAN list.</td>
</tr>
<tr>
<td>KEY_MANAGER</td>
<td>Directory</td>
<td>Key Manager Backend to store keys</td>
</tr>
</tbody>
</table>
<h3 id="configuration-options_4">Configuration Options</h3>
<h3 id="command-line-options_4">Command-Line Options</h3>
<p>The Key Broker Service supports several command-line commands that can be executed only as the Root user:</p>
<p>Syntax:</p>
<p>kbs \&lt;command></p>
<h4 id="start_5">Start</h4>
<p>kbs start</p>
<p>Starts the service</p>
<h4 id="status_5">Status</h4>
<p>kbs status</p>
<p>Displays the current status of the service.</p>
<h4 id="stop_5">Stop</h4>
<p>kbs stop</p>
<p>Stops the service</p>
<h4 id="uninstall_5">Uninstall</h4>
<p>kbs uninstall [--purge]</p>
<p>Removes the service</p>
<h4 id="version_5">Version</h4>
<p>kbs version</p>
<p>Displays the version of the service</p>
<h3 id="directory-layout_5">Directory Layout</h3>
<p>The Key Broker Service installs by default to /opt/kbs with the following folders.</p>
<h4 id="bin_5">Bin</h4>
<p>Contains executable scripts and binaries.</p>
<h2 id="sgx-caching-service_1">SGX Caching Service</h2>
<h3 id="installation-answer-file-options_5">Installation Answer File Options</h3>
<table>
<thead>
<tr>
<th>Key</th>
<th>Sample Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>CMS_BASE_URL</td>
<td>https://&lt; CMS IP or hostname &gt;:8445/cms/v1/</td>
<td>CMS URL for Certificate Management Service</td>
</tr>
<tr>
<td>AAS_API_URL</td>
<td>https://&lt; AAS IP or hostname &gt;:8444/aas</td>
<td>API URL for Authentication Authorization Service</td>
</tr>
<tr>
<td>SCS_ADMIN_USERNAME</td>
<td>scsuser@scs</td>
<td>SCS Service username</td>
</tr>
<tr>
<td>SCS_ADMIN_PASSWORD</td>
<td>scspassword</td>
<td>SCS Service password</td>
</tr>
<tr>
<td>BEARER_TOKEN</td>
<td></td>
<td>Installation Token from AAS</td>
</tr>
<tr>
<td>CMS_TLS_CERT_SHA384</td>
<td>&lt; Certificate Management Service TLS digest &gt;</td>
<td>SHA384  Hash sum for verifying the CMS TLS certificate.</td>
</tr>
<tr>
<td>INTEL_PROVISIONING_SERVER</td>
<td><a href="https://sbx.api.trustedservices.intel.com/sgx/certification/v3">https://sbx.api.trustedservices.intel.com/sgx/certification/v3</a></td>
<td>Intel pcs server url</td>
</tr>
<tr>
<td>INTEL_PROVISIONING_SERVER_API_KEY</td>
<td>&lt; Add your API subscription key &gt;</td>
<td>Intel PCS Server API subscription key</td>
</tr>
<tr>
<td>SCS_REFRESH_HOURS</td>
<td>1 hour</td>
<td>Time after which the SGX collaterals in SCS db get refreshed from  Intel PCS server</td>
</tr>
<tr>
<td>RETRY_COUNT</td>
<td>3</td>
<td>Number Of times to connect to PCS if PCS service is not accessible</td>
</tr>
<tr>
<td>WAIT_TIME</td>
<td>1</td>
<td>Number Of Seconds between retries to connect to PCS</td>
</tr>
<tr>
<td>SCS_DB_HOSTNAME</td>
<td>localhost</td>
<td>SCS Databse hostname</td>
</tr>
<tr>
<td>SCS_DB_PORT</td>
<td>5432</td>
<td>SCS Database port</td>
</tr>
<tr>
<td>SCS_DB_NAME</td>
<td>pgscsdb</td>
<td>SCS Database name</td>
</tr>
<tr>
<td>SCS_DB_USERNAME</td>
<td>aasdbuser</td>
<td>SCS Database username</td>
</tr>
<tr>
<td>SCS_DB_PASSWORD</td>
<td>aasdbpassword</td>
<td>SCS Database password</td>
</tr>
<tr>
<td>SCS_DB_SSLCERTSRC</td>
<td>/usr/local/pgsql/data/server.crt</td>
<td></td>
</tr>
<tr>
<td>SAN_LIST</td>
<td>127.0.0.1,localhost</td>
<td>Comma-separated list of IP addresses and hostnames that will be valid connection points for the service. Requests sent to the service using an IP or hostname not in this list will be denied, even if it resolves to this service.</td>
</tr>
</tbody>
</table>
<h3 id="configuration-options_5">Configuration Options</h3>
<p>The SGX Caching Service configuration can be found in /etc/scs/config.yml.</p>
<h3 id="command-line-options_5">Command-Line Options</h3>
<h4 id="help_5">Help</h4>
<p>Displays the list of available CLI commands.</p>
<h4 id="start_6">start</h4>
<p>scs start</p>
<p>Starts the SGX Caching Service</p>
<h4 id="stop_6">stop</h4>
<p>scs stop</p>
<p>Stops the SGX Caching Service</p>
<h4 id="status_6">status</h4>
<p>scs status</p>
<p>Reports whether the SGX Caching Service is currently running</p>
<h4 id="uninstall_6">uninstall</h4>
<p>scs uninstall [--purge]</p>
<p>uninstall the SGX Caching Service. --purge option needs to be applied to remove configuration files</p>
<h4 id="version_6">version</h4>
<p>scs version</p>
<p>Reports the version of the scs</p>
<h3 id="directory-layout_6">Directory Layout</h3>
<p>The SGX Caching Service installs by default to /opt/scs with the following folders.</p>
<h4 id="bin_6">Bin</h4>
<p>Contains SGX Caching Service executable binary.</p>
<h4 id="dbscripts_1">Dbscripts</h4>
<p>Contains database scripts</p>
<h2 id="sgx-quote-verification">SGX Quote Verification</h2>
<h3 id="installation-answer-file-options_6">Installation Answer File Options</h3>
<table>
<thead>
<tr>
<th>Key</th>
<th>Sample Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>CMS_BASE_URL</td>
<td>https://&lt; CMS IP address or hostname &gt;:8445/cms/v1/</td>
<td>Defines the base URL for the CMS owned by  the image owner. Note that this CMS  may be different from the CMS used for other components.</td>
</tr>
<tr>
<td>AAS_API_URL</td>
<td>https://&lt; AAS IP address or hostname &gt;:8444/aas</td>
<td>Defines the baseurl for the AAS owned by  the image owner. Note that this AAS  may be different from the AAS used for other components.</td>
</tr>
<tr>
<td>SCS_BASE_URL</td>
<td>https://&lt; SCS IP address or hostname &gt;:9000/scs/sgx/certification/v1/</td>
<td>The SCS url is needed.</td>
</tr>
<tr>
<td>SGX_TRUSTED_ROOT_CA_PATH</td>
<td>/tmp/trusted_rootca.pem</td>
<td>The path to SGX root ca used to verify quote</td>
</tr>
<tr>
<td>CMS_TLS_CERT_SHA384</td>
<td>&lt; Certificate Management Service TLS digest &gt;</td>
<td>SHA384 hash of the CMS  TLS certificate</td>
</tr>
<tr>
<td>BEARER_TOKEN</td>
<td></td>
<td>Token from CMS with  permissions used for installation.</td>
</tr>
<tr>
<td>SQVS_LOG_LEVEL</td>
<td>INFO (default), DEBUG</td>
<td>Defines the log level  for the SQVS. Defaults to INFO.</td>
</tr>
<tr>
<td>SQVS_PASSWORD</td>
<td>sqvsuser@sqvs</td>
<td>Defines the credentials for the  SQVS user</td>
</tr>
<tr>
<td>SQVS_USERNAME</td>
<td>sqvspassword</td>
<td>Defines the credentials for the  SQVS User</td>
</tr>
<tr>
<td>SQVS_PORT</td>
<td>12000</td>
<td>SQVS Secure Port</td>
</tr>
<tr>
<td>SQVS_NOSETUP</td>
<td>false</td>
<td>Skips setup during installation if set to true</td>
</tr>
<tr>
<td>SAN_LIST</td>
<td>127.0.0.1,localhost</td>
<td>Comma-separated list of IP addresses and hostnames that will be valid connection points for the service. Requests sent to the service using an IP or hostname not in this list will be denied, even if it resolves to this service.</td>
</tr>
<tr>
<td>SQVS_INCLUDE_TOKEN</td>
<td>true</td>
<td>If true, SQVS will authenticate KBS before Quote Verifiation</td>
</tr>
</tbody>
</table>
<h3 id="configuration-options_6">Configuration Options</h3>
<p>The SGX Quote Verification Service configuration can be found in /etc/sqvs/config.yml.</p>
<h3 id="command-line-options_6">Command-Line Options</h3>
<p>The SGX Quote Verifiction Service supports several command-line commands:</p>
<p>Syntax:</p>
<p>sqvs \&lt;command></p>
<h4 id="help_6">Help</h4>
<p>Displays the list of available CLI commands.</p>
<h4 id="start_7">start</h4>
<p>sqvs start</p>
<p>Starts the SGX Quote Verification Service</p>
<h4 id="stop_7">stop</h4>
<p>sqvs stop</p>
<p>Stops the SGX Quote Verification Service</p>
<h4 id="status_7">status</h4>
<p>sqvs status</p>
<p>Reports whether the SGX Quote Verification Service is currently running.</p>
<h4 id="uninstall_7">uninstall</h4>
<p>sqvs uninstall [--purge]</p>
<p>uninstalls the SGX Quote Verification Service. --purge option needs to be applied to remove configuration files</p>
<h4 id="version_7">version</h4>
<p>sqvs version</p>
<p>Reports the version of the sqvs</p>
<h1 id="uninstallation">Uninstallation</h1>
<p>This section describes steps used for uninstalling Intel SecL-DC services.</p>
<h2 id="certificate-management-service_2">Certificate Management Service</h2>
<p>To uninstall the Certificate Management Service, run the following command:</p>
<p>cms uninstall --purge</p>
<p>Removes following directories:</p>
<ol>
<li>
<p>/opt/cms</p>
</li>
<li>
<p>/run/cms</p>
</li>
<li>
<p>/var/log/cms</p>
</li>
<li>
<p>/etc/cms</p>
</li>
</ol>
<h2 id="authentication-and-authorization-service_2">Authentication and Authorization Service</h2>
<p>To uninstall the Authentication and Authorization Service, run the following command:</p>
<p>authservice uninstall --purge</p>
<p>Removes following directories:</p>
<ol>
<li>
<p>/opt/authservice</p>
</li>
<li>
<p>/run/authservice</p>
</li>
<li>
<p>/var/log/authservice</p>
</li>
<li>
<p>/etc/authservice</p>
</li>
</ol>
<h2 id="sgx-host-verification-service_2">SGX Host Verification Service</h2>
<p>To uninstall the SGX Host Verification Service, run the following command:</p>
<p>shvs uninstall --purge</p>
<p>Removes following directories:</p>
<ol>
<li>
<p>/opt/shvs</p>
</li>
<li>
<p>/run/shvs</p>
</li>
<li>
<p>/var/log/shvs</p>
</li>
<li>
<p>/etc/shvs</p>
</li>
</ol>
<h2 id="sgx_agent">SGX_Agent</h2>
<p>To uninstall the SGX Agent, run the following command: </p>
<p>sgx_agent uninstall --purge</p>
<p>Removes following directories:</p>
<ol>
<li>
<p>/opt/sgx_agent</p>
</li>
<li>
<p>/run/sgx_agent</p>
</li>
<li>
<p>/var/log/sgx_agent</p>
</li>
<li>
<p>/etc/sgx_agent</p>
</li>
</ol>
<h2 id="integration-hub_2">Integration Hub</h2>
<p>To uninstall the Integration Hub, run the following command:</p>
<p>ihub uninstall --purge</p>
<p>Removes the following directories:</p>
<ol>
<li>
<p>/opt/ihub</p>
</li>
<li>
<p>/run/ihub</p>
</li>
<li>
<p>/var/log/ihub</p>
</li>
<li>
<p>/etc/ihub</p>
</li>
</ol>
<h2 id="sgx-caching-service_2">SGX Caching Service</h2>
<p>To uninstall the SGX Caching Service , run the following command:</p>
<p>scs uninstall --purge</p>
<p>Removes the following directories:</p>
<ol>
<li>
<p>/opt/scs</p>
</li>
<li>
<p>/run/scs</p>
</li>
<li>
<p>/var/log/scs</p>
</li>
<li>
<p>/etc/scs</p>
</li>
</ol>
<h2 id="sgx-quote-verification-service_1">SGX Quote Verification Service</h2>
<p>To uninstall the SGX Quote Verification Service, run the following command:</p>
<p>sqvs uninstall --purge</p>
<p>Removes the following directories:</p>
<ol>
<li>
<p>/opt/sqvs</p>
</li>
<li>
<p>/run/sqvs</p>
</li>
<li>
<p>/var/log/sqvs</p>
</li>
<li>
<p>/etc/sqvs</p>
</li>
</ol>
<h2 id="key-broker-service_1">Key Broker Service</h2>
<p>kbs uninstall --purge</p>
<p>To uninstall the Key Broker Service , run the following command:</p>
<p>Removes the following directories:</p>
<ol>
<li>
<p>/opt/kbs</p>
</li>
<li>
<p>/run/kbs</p>
</li>
<li>
<p>/var/log/kbs</p>
</li>
<li>
<p>/etc/kbs</p>
</li>
</ol>
<h2 id="skc-library">SKC Library</h2>
<p>To uninstall the SKC Library, run the following command:</p>
<p>./opt/skc/devops/scripts/uninstall.sh</p>
<p>Removes the following directories:</p>
<p>/opt/skc</p>
<h2 id="isecl-k8s-extensions">isecl-k8s-extensions</h2>
<p>Cluster admin can uninstall the isecl-k8s-extensions by running following commands:</p>
<div class="highlight"><pre><span></span><code>    kubectl delete svc isecl-scheduler-svc -n isecl
    kubectl delete deployment isecl-controller isecl-scheduler -n isecl
    kubectl delete crds hostattributes.crd.isecl.intel.com
    rm -rf /opt/isecl-k8s-extensions
    rm -rf /var/log/isecl-k8s-extensions
</code></pre></div>
<h1 id="appendix">Appendix</h1>
<p>Sample Shell script to create KBS user, KBS Roles and mapping KBS user to KBS roles and generating a KBS Token from AAS</p>
<h4 id="sample-script-to-create-key-broker-service-user-account-and-roles">Sample Script to create Key Broker Service User account and roles</h4>
<div class="highlight"><pre><span></span><code>#!/bin/bash
echo &quot;Setting up Key Broker Service Related roles and user in AAS Database&quot;

source ~/kbs.env 2&gt; /dev/null

aas_hostname=${AAS_API_URL:-&quot;https://&lt;aas.server.com&gt;:8444/aas&quot;}
CURL_OPTS=&quot;-s -k&quot;
CONTENT_TYPE=&quot;Content-Type: application/json&quot;
ACCEPT=&quot;Accept: application/jwt&quot;

red=`tput setaf 1`
green=`tput setaf 2`
reset=`tput sgr0`

mkdir -p /tmp/kbs
tmpdir=$(mktemp -d -p /tmp/kbs)

dnf install -yq jq

Bearer_token=`curl $CURL_OPTS -X POST $aas_hostname/token -d &#39;{&quot;username&quot;: &quot;admin@aas&quot;, &quot;password&quot;: &quot;aasAdminPass&quot; }&#39;`

# This routine checks if kbs user exists and returns user id
# it creates a new user if one does not exist
create_kbs_user()
{
cat &gt; $tmpdir/user.json &lt;&lt; EOF
{
        &quot;username&quot;:&quot;$KBS_SERVICE_USERNAME&quot;,
        &quot;password&quot;:&quot;$KBS_SERVICE_PASSWORD&quot;
}
EOF
        #check if kbs user already exists
        curl $CURL_OPTS -H &quot;Authorization: Bearer ${Bearer_token}&quot; -o $tmpdir/user_response.json -w &quot;%{http_code}&quot; $aas_hostname/users?name=$KBS_SERVICE_USERNAME &gt; $tmpdir/user-response.status

        len=$(jq &#39;. | length&#39; &lt; $tmpdir/user_response.json)
        if [ $len -ne 0 ]; then
                user_id=$(jq -r &#39;.[0] .user_id&#39; &lt; $tmpdir/user_response.json)
        else
                curl $CURL_OPTS -X POST -H &quot;$CONTENT_TYPE&quot; -H &quot;Authorization: Bearer ${Bearer_token}&quot; --data @$tmpdir/user.json -o $tmpdir/user_response.json -w &quot;%{http_code}&quot; $aas_hostname/users &gt; $tmpdir/user_response.status

                local status=$(cat $tmpdir/user_response.status)
                if [ $status -ne 201 ]; then
                        return 1
                fi

                if [ -s $tmpdir/user_response.json ]; then
                        user_id=$(jq -r &#39;.user_id&#39; &lt; $tmpdir/user_response.json)
                        if [ -n &quot;$user_id&quot; ]; then
                                echo &quot;${green} Created kbs user, id: $user_id ${reset}&quot;
                        fi
                fi
        fi
}

# This routine checks if kbs CertApprover/Administrator/QuoteVerifier roles exist and returns those role ids
# it creates above roles if not present in AAS db
create_roles()
{
cat &gt; $tmpdir/certroles.json &lt;&lt; EOF
{
        &quot;service&quot;: &quot;CMS&quot;,
        &quot;name&quot;: &quot;CertApprover&quot;,
        &quot;context&quot;: &quot;CN=$TLS_COMMON_NAME;SAN=$TLS_SAN_LIST;CERTTYPE=TLS&quot;
}
EOF

cat &gt; $tmpdir/quoteverifyroles.json &lt;&lt; EOF
{
        &quot;service&quot;: &quot;SQVS&quot;,
        &quot;name&quot;: &quot;QuoteVerifier&quot;,
        &quot;context&quot;: &quot;&quot;
}
EOF

        #check if CertApprover role already exists
        curl $CURL_OPTS -H &quot;Authorization: Bearer ${Bearer_token}&quot; -o $tmpdir/role_response.json -w &quot;%{http_code}&quot; $aas_hostname/roles?name=CertApprover &gt; $tmpdir/role_response.status

        cms_role_id=$(jq --arg SAN $TLS_SAN_LIST -r &#39;.[] | select ( .context | ( contains(&quot;KBS&quot;) and contains($SAN)))&#39; &lt; $tmpdir/role_response.json | jq -r &#39;.role_id&#39;)
        if [ -z $cms_role_id ]; then
                curl $CURL_OPTS -X POST -H &quot;$CONTENT_TYPE&quot; -H &quot;Authorization: Bearer ${Bearer_token}&quot; --data @$tmpdir/certroles.json -o $tmpdir/role_response.json -w &quot;%{http_code}&quot; $aas_hostname/roles &gt; $tmpdir/role_response-status.json

                local status=$(cat $tmpdir/role_response-status.json)
                if [ $status -ne 201 ]; then
                        return 1
                fi

                if [ -s $tmpdir/role_response.json ]; then
                        cms_role_id=$(jq -r &#39;.role_id&#39; &lt; $tmpdir/role_response.json)
                fi
        fi

        # get admin role id
        admin_role_id=`curl $CURL_OPTS $aas_hostname/roles?name=Administrator -H &quot;$CONTENT_TYPE&quot; -H &quot;Authorization: Bearer ${Bearer_token}&quot; | jq -r &#39;.[0].role_id&#39;`

        #check if QuoteVerifier role already exists
        curl $CURL_OPTS -H &quot;Authorization: Bearer ${Bearer_token}&quot; -o $tmpdir/role_resp.json -w &quot;%{http_code}&quot; $aas_hostname/roles?name=QuoteVerifier &gt; $tmpdir/role_resp.status

        len=$(jq &#39;. | length&#39; &lt; $tmpdir/role_resp.json)
        if [ $len -ne 0 ]; then
                sqvs_role_id=$(jq -r &#39;.[0] .role_id&#39; &lt; $tmpdir/role_resp.json)
        else
                curl $CURL_OPTS -X POST -H &quot;$CONTENT_TYPE&quot; -H &quot;Authorization: Bearer ${Bearer_token}&quot; --data @$tmpdir/quoteverifyroles.json -o $tmpdir/role_resp.json -w &quot;%{http_code}&quot; $aas_hostname/roles &gt; $tmpdir/role_resp-status.json

                local status=$(cat $tmpdir/role_resp-status.json)
                if [ $status -ne 201 ]; then
                        return 1
                fi

                if [ -s $tmpdir/role_resp.json ]; then
                        sqvs_role_id=$(jq -r &#39;.role_id&#39; &lt; $tmpdir/role_resp.json)
                fi
        fi
        ROLE_ID_TO_MAP=`echo \&quot;$cms_role_id\&quot;,\&quot;$admin_role_id\&quot;,\&quot;$sqvs_role_id\&quot;`
}

#Maps kbs user to CertApprover/Administrator/QuoteVerifier Roles
mapUser_to_role()
{
cat &gt;$tmpdir/mapRoles.json &lt;&lt;EOF
{
        &quot;role_ids&quot;: [$ROLE_ID_TO_MAP]
}
EOF
        curl $CURL_OPTS -X POST -H &quot;$CONTENT_TYPE&quot; -H &quot;Authorization: Bearer ${Bearer_token}&quot; --data @$tmpdir/mapRoles.json -o $tmpdir/mapRoles_response.json -w &quot;%{http_code}&quot; $aas_hostname/users/$user_id/roles &gt; $tmpdir/mapRoles_response-status.json

        local status=$(cat $tmpdir/mapRoles_response-status.json)
        if [ $status -ne 201 ]; then
                return 1
        fi
}

KBS_SETUP_API=&quot;create_kbs_user create_roles mapUser_to_role&quot;
status=
for api in $KBS_SETUP_API
do
        eval $api
        status=$?
        if [ $status -ne 0 ]; then
                break;
        fi
done

if [ $status -ne 0 ]; then
        echo &quot;${red} Key Broking Service user/roles creation failed.: $api ${reset}&quot;
        exit 1
else
        echo &quot;${green} Key Broking Service user/roles creation succeded ${reset}&quot;
fi

#Get Token for Key Broking Service user and configure it in kbs config.
curl $CURL_OPTS -X POST -H &quot;$CONTENT_TYPE&quot; -H &quot;$ACCEPT&quot; --data @$tmpdir/user.json -o $tmpdir/kbs_token-resp.json -w &quot;%{http_code}&quot; $aas_hostname/token &gt; $tmpdir/get_kbs_token-response.status

status=$(cat $tmpdir/get_kbs_token-response.status)
if [ $status -ne 200 ]; then
        echo &quot;${red} Couldn&#39;t get bearer token for kbs user ${reset}&quot;
else
        export BEARER_TOKEN=`cat $tmpdir/kbs_token-resp.json`
        echo &quot;************************************************************************************************************************************************&quot;
        echo $BEARER_TOKEN
        echo &quot;************************************************************************************************************************************************&quot;
        echo &quot;${green} copy the above token and paste it against BEARER_TOKEN in kbs.env ${reset}&quot;
fi

# cleanup
rm -rf $tmpdir
</code></pre></div>
<p>The printed token needs to be added in BEARER_TOKEN section in kbs.env</p>
<h4 id="sample-script-to-create-integrated-hub-user-account-and-roles">Sample Script to Create Integrated Hub User account and Roles</h4>
<div class="highlight"><pre><span></span><code>#!/bin/bash
echo &quot;Setting up Integration Hub Service Related roles and user in AAS Database&quot;

source ~/ihub.env 2&gt; /dev/null

aas_hostname=${AAS_API_URL:-&quot;https://&lt;aas.server.com&gt;:8444/aas&quot;}
CN=&quot;Integration Hub TLS Certificate&quot;
CURL_OPTS=&quot;-s -k&quot;
CONTENT_TYPE=&quot;Content-Type: application/json&quot;
ACCEPT=&quot;Accept: application/jwt&quot;

red=`tput setaf 1`
green=`tput setaf 2`
reset=`tput sgr0`

mkdir -p /tmp/ihub
tmpdir=$(mktemp -d -p /tmp/ihub)

dnf install -yq jq

Bearer_token=`curl $CURL_OPTS -X POST $aas_hostname/token -d &#39;{&quot;username&quot;: &quot;admin@aas&quot;, &quot;password&quot;: &quot;aasAdminPass&quot; }&#39;`

# This routine checks if ihub user exists and returns user id
# it creates a new user if one does not exist
create_ihub_user()
{
cat &gt; $tmpdir/user.json &lt;&lt; EOF
{
        &quot;username&quot;:&quot;$IHUB_SERVICE_USERNAME&quot;,
        &quot;password&quot;:&quot;$IHUB_SERVICE_PASSWORD&quot;
}
EOF
        #check if ihub user already exists
        curl $CURL_OPTS -H &quot;Authorization: Bearer ${Bearer_token}&quot; -o $tmpdir/user_response.json -w &quot;%{http_code}&quot; $aas_hostname/users?name=$IHUB_SERVICE_USERNAME &gt; $tmpdir/user-response.status

        len=$(jq &#39;. | length&#39; &lt; $tmpdir/user_response.json)
        if [ $len -ne 0 ]; then
                user_id=$(jq -r &#39;.[0] .user_id&#39; &lt; $tmpdir/user_response.json)
        else
                curl $CURL_OPTS -X POST -H &quot;$CONTENT_TYPE&quot; -H &quot;Authorization: Bearer ${Bearer_token}&quot; --data @$tmpdir/user.json -o $tmpdir/user_response.json -w &quot;%{http_code}&quot; $aas_hostname/users &gt; $tmpdir/user_response.status

                local status=$(cat $tmpdir/user_response.status)
                if [ $status -ne 201 ]; then
                        return 1
                fi

                if [ -s $tmpdir/user_response.json ]; then
                        user_id=$(jq -r &#39;.user_id&#39; &lt; $tmpdir/user_response.json)
                        if [ -n &quot;$user_id&quot; ]; then
                                echo &quot;${green} Created ihub user, id: $user_id ${reset}&quot;
                        fi
                fi
        fi
}

# This routine checks if ihub CertApprover/HostsListReader/HostDataReader roles exist and returns those role ids
# it creates above roles if not present in AAS db
create_roles()
{
cat &gt; $tmpdir/certroles.json &lt;&lt; EOF
{
        &quot;service&quot;: &quot;CMS&quot;,
        &quot;name&quot;: &quot;CertApprover&quot;,
        &quot;context&quot;: &quot;CN=$CN;SAN=$TLS_SAN_LIST;CERTTYPE=TLS&quot;
}
EOF

cat &gt; $tmpdir/hostlistreadroles.json &lt;&lt; EOF
{
        &quot;service&quot;: &quot;SHVS&quot;,
        &quot;name&quot;: &quot;HostsListReader&quot;,
        &quot;context&quot;: &quot;&quot;
}
EOF

cat &gt; $tmpdir/hostdatareadroles.json &lt;&lt; EOF
{
        &quot;service&quot;: &quot;SHVS&quot;,
        &quot;name&quot;: &quot;HostDataReader&quot;,
        &quot;context&quot;: &quot;&quot;
}
EOF
        #check if CertApprover role already exists
        curl $CURL_OPTS -H &quot;Authorization: Bearer ${Bearer_token}&quot; -o $tmpdir/role_response.json -w &quot;%{http_code}&quot; $aas_hostname/roles?name=CertApprover &gt; $tmpdir/role_response.status

        cms_role_id=$(jq --arg SAN $TLS_SAN_LIST -r &#39;.[] | select ( .context | ( contains(&quot;Integration Hub&quot;) and contains($SAN)))&#39; &lt; $tmpdir/role_response.json | jq -r &#39;.role_id&#39;)
        if [ -z $cms_role_id ]; then
                curl $CURL_OPTS -X POST -H &quot;$CONTENT_TYPE&quot; -H &quot;Authorization: Bearer ${Bearer_token}&quot; --data @$tmpdir/certroles.json -o $tmpdir/role_response.json -w &quot;%{http_code}&quot; $aas_hostname/roles &gt; $tmpdir/role_response-status.json

                local status=$(cat $tmpdir/role_response-status.json)
                if [ $status -ne 201 ]; then
                        return 1
                fi

                if [ -s $tmpdir/role_response.json ]; then
                        cms_role_id=$(jq -r &#39;.role_id&#39; &lt; $tmpdir/role_response.json)
                fi
        fi

        #check if HostsListReader role already exists
        curl $CURL_OPTS -H &quot;Authorization: Bearer ${Bearer_token}&quot; -o $tmpdir/role_resp.json -w &quot;%{http_code}&quot; $aas_hostname/roles?name=HostsListReader &gt; $tmpdir/role_resp.status
        len=$(jq &#39;. | length&#39; &lt; $tmpdir/role_resp.json)
        if [ $len -ne 0 ]; then
                ihub_role_id1=$(jq -r &#39;.[0] .role_id&#39; &lt; $tmpdir/role_resp.json)
        else
                curl $CURL_OPTS -X POST -H &quot;$CONTENT_TYPE&quot; -H &quot;Authorization: Bearer ${Bearer_token}&quot; --data @$tmpdir/hostlistreadroles.json -o $tmpdir/role_resp.json -w &quot;%{http_code}&quot; $aas_hostname/roles &gt; $tmpdir/role_resp-status.json

                local status=$(cat $tmpdir/role_resp-status.json)
                if [ $status -ne 201 ]; then
                        return 1
                fi

                if [ -s $tmpdir/role_resp.json ]; then
                        ihub_role_id1=$(jq -r &#39;.role_id&#39; &lt; $tmpdir/role_resp.json)
                fi
        fi

        #check if HostDataReader role already exists
        curl $CURL_OPTS -H &quot;Authorization: Bearer ${Bearer_token}&quot; -o $tmpdir/role_resp.json -w &quot;%{http_code}&quot; $aas_hostname/roles?name=HostDataReader &gt; $tmpdir/role_resp.status

        ihub_role_id2=$(jq -r &#39;.[] | select ( .service | contains(&quot;SHVS&quot;))&#39; &lt; $tmpdir/role_resp.json | jq -r &#39;.role_id&#39;)
        if [ -z $ihub_role_id2 ]; then
                curl $CURL_OPTS -X POST -H &quot;$CONTENT_TYPE&quot; -H &quot;Authorization: Bearer ${Bearer_token}&quot; --data @$tmpdir/hostdatareadroles.json -o $tmpdir/role_resp.json -w &quot;%{http_code}&quot; $aas_hostname/roles &gt; $tmpdir/role_resp-status.json

                local status=$(cat $tmpdir/role_resp-status.json)
                if [ $status -ne 201 ]; then
                        return 1
                fi

                if [ -s $tmpdir/role_resp.json ]; then
                        ihub_role_id2=$(jq -r &#39;.role_id&#39; &lt; $tmpdir/role_resp.json)
                fi
        fi

        ROLE_ID_TO_MAP=`echo \&quot;$cms_role_id\&quot;,\&quot;$ihub_role_id1\&quot;,\&quot;$ihub_role_id2\&quot;`
}

#Maps ihub user to CertApprover/HostsListReader/HostDataReader Roles
mapUser_to_role()
{
cat &gt;$tmpdir/mapRoles.json &lt;&lt;EOF
{
        &quot;role_ids&quot;: [$ROLE_ID_TO_MAP]
}
EOF
        curl $CURL_OPTS -X POST -H &quot;$CONTENT_TYPE&quot; -H &quot;Authorization: Bearer ${Bearer_token}&quot; --data @$tmpdir/mapRoles.json -o $tmpdir/mapRoles_response.json -w &quot;%{http_code}&quot; $aas_hostname/users/$user_id/roles &gt; $tmpdir/mapRoles_response-status.json

        local status=$(cat $tmpdir/mapRoles_response-status.json)
        if [ $status -ne 201 ]; then
                return 1
        fi
}

IHUB_SETUP_API=&quot;create_ihub_user create_roles mapUser_to_role&quot;
status=
for api in $IHUB_SETUP_API
do
        eval $api
        status=$?
        if [ $status -ne 0 ]; then
                break;
        fi
done

if [ $status -ne 0 ]; then
        echo &quot;${red} Integration Hub Service user/roles creation failed.: $api ${reset}&quot;
        exit 1
else
        echo &quot;${green} Integration Hub Service user/roles creation succeded ${reset}&quot;
fi

#Get Token for Integration Hub Service user and configure it in ihub config.
curl $CURL_OPTS -X POST -H &quot;$CONTENT_TYPE&quot; -H &quot;$ACCEPT&quot; --data @$tmpdir/user.json -o $tmpdir/ihub_token-resp.json -w &quot;%{http_code}&quot; $aas_hostname/token &gt; $tmpdir/get_ihub_token-response.status

status=$(cat $tmpdir/get_ihub_token-response.status)
if [ $status -ne 200 ]; then
        echo &quot;${red} Couldn&#39;t get bearer token for ihub user ${reset}&quot;
else
        export BEARER_TOKEN=`cat $tmpdir/ihub_token-resp.json`
        echo &quot;************************************************************************************************************************************************&quot;
        echo $BEARER_TOKEN
        echo &quot;************************************************************************************************************************************************&quot;
        echo &quot;${green} copy the above token and paste it against BEARER_TOKEN in ihub.env ${reset}&quot;
fi

# cleanup
rm -rf $tmpdir
</code></pre></div>
<p>The printed token needs to be added in BEARER_TOKEN section in ihub.env</p>
<h2 id="creating-rsa-keys-in-key-broker-service">Creating RSA Keys in Key Broker Service</h2>
<p><strong>Configuration Update to create Keys in KBS</strong></p>
<p>On the Enterprise VM, where Key broker service is running</p>
<pre><code>cd /root/binaries/kbs_script

Update KBS and AAS IP addresses in run.sh

Update CACERT_PATH variable with trustedca certificate inside directory /etc/kbs/certs/trustedca/&lt;id.pem&gt;.
</code></pre>
<p><strong>Create RSA Key</strong></p>
<pre><code>Execute the command

./run.sh reg
</code></pre>
<ul>
<li>copy the generated cert file to SGX compute node where skc_library is deployed. Also note down the the key id generated</li>
</ul>
<h2 id="configuration-for-nginx-testing">Configuration for NGINX testing</h2>
<p><strong>Note:</strong> Below mentioned OpenSSL and NGINX configuration updates are provided as patches (nginx.patch and openssl.patch) as part of skc_library deployment script.</p>
<p><strong>OpenSSL Configuration</strong></p>
<p>Update openssl configuration file /etc/pki/tls/openssl.cnf with below changes:</p>
<p>[openssl_def]
engines = engine_section</p>
<p>[engine_section]
pkcs11 = pkcs11_section</p>
<p>[pkcs11_section]
engine_id = pkcs11</p>
<p>dynamic_path =/usr/lib64/engines-1.1/pkcs11.so</p>
<p>MODULE_PATH =/opt/skc/lib/libpkcs11-api.so</p>
<p>init = 0</p>
<p><strong>Nginx Configuration</strong></p>
<p>Update nginx configuration file /etc/nginx/nginx.conf with below changes:</p>
<p>ssl_engine pkcs11;</p>
<p>Update the location of certificate with the location where it was copied into the SGX compute node. </p>
<p>ssl_certificate "add absolute path of crt file"; </p>
<p>Update the KeyID with the KeyID received when RSA key was generated in KBS</p>
<p>ssl_certificate_key "engine:pkcs11:pkcs11:token=KMS;id=164b41ae-be61-4c7c-a027-4a2ab1e5e4c4;object=RSAKEY;type=private;pin-value=1234";</p>
<p><strong>SKC Configuration</strong></p>
<p>Create keys.txt in /tmp folder. This provides key preloading functionality in skc_library. </p>
<p>Any number of keys can be added in keys.txt. Each PKCS11 URL should contain different Key IDs which need to be transferred from KBS along with respective object tag for each key id specified</p>
<p>Last PKCS11 url entry in keys.txt should match with the one in nginx.conf</p>
<p>The keyID should match the keyID of RSA key created in KBS. Other contents should match with nginx.conf. File location should match on pkcs11-apimodule.ini; </p>
<pre><code>pkcs11:token=KMS;id=164b41ae-be61-4c7c-a027-4a2ab1e5e4c4;object=RSAKEY;type=private;pin-value=1234;

Sample /opt/skc/etc/pkcs11-apimodule.ini file

[core]
preload_keys=/tmp/keys.txt
keyagent_conf=/opt/skc/etc/key-agent.ini
mode=SGX
debug=true

[SW]
module=/usr/lib64/pkcs11/libsofthsm2.so

[SGX]
module=/opt/intel/cryptoapitoolkit/lib/libp11sgx.so
</code></pre>
<h1 id="kbs-key-transfer-flow-validation">KBS key-transfer flow validation</h1>
<p>On SGX compute node, Execute below commands for KBS key-transfer:</p>
<div class="highlight"><pre><span></span><code>    pkill nginx
</code></pre></div>
<p>Remove any existing pkcs11 token</p>
<div class="highlight"><pre><span></span><code>    rm -rf /opt/intel/cryptoapitoolkit/tokens/*
</code></pre></div>
<p>Initiate Key tranfer from KBS</p>
<div class="highlight"><pre><span></span><code>    systemctl restart nginx
</code></pre></div>
<p>Changing group ownership and permissions of pkcs11 token
<div class="highlight"><pre><span></span><code>    groupadd intel
    usermod -G intel nginx
    chown -R root:intel /opt/intel/cryptoapitoolkit/tokens/
    chmod -R 770 /opt/intel/cryptoapitoolkit/tokens/
</code></pre></div></p>
<p>Establish tls session with the nginx using the key transferred inside the enclave</p>
<div class="highlight"><pre><span></span><code>    wget https://localhost:2443 --no-check-certificate
</code></pre></div>
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid" aria-label="Footer">
        
          <a href="../Product%20Guide%20-%20Intel%C2%AE%20Security%20Libraries%20-%20Datacenter%20Foundational%20Security/" class="md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-footer-nav__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
            </div>
            <div class="md-footer-nav__title">
              <div class="md-ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Intel® Security Libraries - Datacenter Foundational Security
              </div>
            </div>
          </a>
        
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/vendor.93c04032.min.js"></script>
      <script src="../../assets/javascripts/bundle.83e5331e.min.js"></script><script id="__lang" type="application/json">{"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}</script>
      
      <script>
        app = initialize({
          base: "../..",
          features: [],
          search: Object.assign({
            worker: "../../assets/javascripts/worker/search.8c7e0a7e.min.js"
          }, typeof search !== "undefined" && search)
        })
      </script>
      
    
  </body>
</html>